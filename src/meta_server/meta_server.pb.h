// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: meta_server.proto

#ifndef PROTOBUF_INCLUDED_meta_5fserver_2eproto
#define PROTOBUF_INCLUDED_meta_5fserver_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_meta_5fserver_2eproto 

namespace protobuf_meta_5fserver_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_meta_5fserver_2eproto
namespace meta_server {
class PartionkeyNameRequest;
class PartionkeyNameRequestDefaultTypeInternal;
extern PartionkeyNameRequestDefaultTypeInternal _PartionkeyNameRequest_default_instance_;
class PartionkeyNameResponse;
class PartionkeyNameResponseDefaultTypeInternal;
extern PartionkeyNameResponseDefaultTypeInternal _PartionkeyNameResponse_default_instance_;
class PartitionLocationRequest;
class PartitionLocationRequestDefaultTypeInternal;
extern PartitionLocationRequestDefaultTypeInternal _PartitionLocationRequest_default_instance_;
class PartitionLocationRequest_Range;
class PartitionLocationRequest_RangeDefaultTypeInternal;
extern PartitionLocationRequest_RangeDefaultTypeInternal _PartitionLocationRequest_Range_default_instance_;
class PartitionLocationResponse;
class PartitionLocationResponseDefaultTypeInternal;
extern PartitionLocationResponseDefaultTypeInternal _PartitionLocationResponse_default_instance_;
class PartitionLocationResponse_ReplicaLocation;
class PartitionLocationResponse_ReplicaLocationDefaultTypeInternal;
extern PartitionLocationResponse_ReplicaLocationDefaultTypeInternal _PartitionLocationResponse_ReplicaLocation_default_instance_;
}  // namespace meta_server
namespace google {
namespace protobuf {
template<> ::meta_server::PartionkeyNameRequest* Arena::CreateMaybeMessage<::meta_server::PartionkeyNameRequest>(Arena*);
template<> ::meta_server::PartionkeyNameResponse* Arena::CreateMaybeMessage<::meta_server::PartionkeyNameResponse>(Arena*);
template<> ::meta_server::PartitionLocationRequest* Arena::CreateMaybeMessage<::meta_server::PartitionLocationRequest>(Arena*);
template<> ::meta_server::PartitionLocationRequest_Range* Arena::CreateMaybeMessage<::meta_server::PartitionLocationRequest_Range>(Arena*);
template<> ::meta_server::PartitionLocationResponse* Arena::CreateMaybeMessage<::meta_server::PartitionLocationResponse>(Arena*);
template<> ::meta_server::PartitionLocationResponse_ReplicaLocation* Arena::CreateMaybeMessage<::meta_server::PartitionLocationResponse_ReplicaLocation>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace meta_server {

// ===================================================================

class PartionkeyNameRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:meta_server.PartionkeyNameRequest) */ {
 public:
  PartionkeyNameRequest();
  virtual ~PartionkeyNameRequest();

  PartionkeyNameRequest(const PartionkeyNameRequest& from);

  inline PartionkeyNameRequest& operator=(const PartionkeyNameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PartionkeyNameRequest(PartionkeyNameRequest&& from) noexcept
    : PartionkeyNameRequest() {
    *this = ::std::move(from);
  }

  inline PartionkeyNameRequest& operator=(PartionkeyNameRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PartionkeyNameRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartionkeyNameRequest* internal_default_instance() {
    return reinterpret_cast<const PartionkeyNameRequest*>(
               &_PartionkeyNameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(PartionkeyNameRequest* other);
  friend void swap(PartionkeyNameRequest& a, PartionkeyNameRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PartionkeyNameRequest* New() const final {
    return CreateMaybeMessage<PartionkeyNameRequest>(NULL);
  }

  PartionkeyNameRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PartionkeyNameRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PartionkeyNameRequest& from);
  void MergeFrom(const PartionkeyNameRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartionkeyNameRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string db_name = 1;
  void clear_db_name();
  static const int kDbNameFieldNumber = 1;
  const ::std::string& db_name() const;
  void set_db_name(const ::std::string& value);
  #if LANG_CXX11
  void set_db_name(::std::string&& value);
  #endif
  void set_db_name(const char* value);
  void set_db_name(const char* value, size_t size);
  ::std::string* mutable_db_name();
  ::std::string* release_db_name();
  void set_allocated_db_name(::std::string* db_name);

  // string tab_name = 2;
  void clear_tab_name();
  static const int kTabNameFieldNumber = 2;
  const ::std::string& tab_name() const;
  void set_tab_name(const ::std::string& value);
  #if LANG_CXX11
  void set_tab_name(::std::string&& value);
  #endif
  void set_tab_name(const char* value);
  void set_tab_name(const char* value, size_t size);
  ::std::string* mutable_tab_name();
  ::std::string* release_tab_name();
  void set_allocated_tab_name(::std::string* tab_name);

  // @@protoc_insertion_point(class_scope:meta_server.PartionkeyNameRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr db_name_;
  ::google::protobuf::internal::ArenaStringPtr tab_name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_meta_5fserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PartionkeyNameResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:meta_server.PartionkeyNameResponse) */ {
 public:
  PartionkeyNameResponse();
  virtual ~PartionkeyNameResponse();

  PartionkeyNameResponse(const PartionkeyNameResponse& from);

  inline PartionkeyNameResponse& operator=(const PartionkeyNameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PartionkeyNameResponse(PartionkeyNameResponse&& from) noexcept
    : PartionkeyNameResponse() {
    *this = ::std::move(from);
  }

  inline PartionkeyNameResponse& operator=(PartionkeyNameResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PartionkeyNameResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartionkeyNameResponse* internal_default_instance() {
    return reinterpret_cast<const PartionkeyNameResponse*>(
               &_PartionkeyNameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(PartionkeyNameResponse* other);
  friend void swap(PartionkeyNameResponse& a, PartionkeyNameResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PartionkeyNameResponse* New() const final {
    return CreateMaybeMessage<PartionkeyNameResponse>(NULL);
  }

  PartionkeyNameResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PartionkeyNameResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PartionkeyNameResponse& from);
  void MergeFrom(const PartionkeyNameResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartionkeyNameResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string partition_key_name = 1;
  void clear_partition_key_name();
  static const int kPartitionKeyNameFieldNumber = 1;
  const ::std::string& partition_key_name() const;
  void set_partition_key_name(const ::std::string& value);
  #if LANG_CXX11
  void set_partition_key_name(::std::string&& value);
  #endif
  void set_partition_key_name(const char* value);
  void set_partition_key_name(const char* value, size_t size);
  ::std::string* mutable_partition_key_name();
  ::std::string* release_partition_key_name();
  void set_allocated_partition_key_name(::std::string* partition_key_name);

  // @@protoc_insertion_point(class_scope:meta_server.PartionkeyNameResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr partition_key_name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_meta_5fserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PartitionLocationRequest_Range : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:meta_server.PartitionLocationRequest.Range) */ {
 public:
  PartitionLocationRequest_Range();
  virtual ~PartitionLocationRequest_Range();

  PartitionLocationRequest_Range(const PartitionLocationRequest_Range& from);

  inline PartitionLocationRequest_Range& operator=(const PartitionLocationRequest_Range& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PartitionLocationRequest_Range(PartitionLocationRequest_Range&& from) noexcept
    : PartitionLocationRequest_Range() {
    *this = ::std::move(from);
  }

  inline PartitionLocationRequest_Range& operator=(PartitionLocationRequest_Range&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PartitionLocationRequest_Range& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartitionLocationRequest_Range* internal_default_instance() {
    return reinterpret_cast<const PartitionLocationRequest_Range*>(
               &_PartitionLocationRequest_Range_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(PartitionLocationRequest_Range* other);
  friend void swap(PartitionLocationRequest_Range& a, PartitionLocationRequest_Range& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PartitionLocationRequest_Range* New() const final {
    return CreateMaybeMessage<PartitionLocationRequest_Range>(NULL);
  }

  PartitionLocationRequest_Range* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PartitionLocationRequest_Range>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PartitionLocationRequest_Range& from);
  void MergeFrom(const PartitionLocationRequest_Range& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionLocationRequest_Range* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 min_range = 1;
  void clear_min_range();
  static const int kMinRangeFieldNumber = 1;
  ::google::protobuf::int64 min_range() const;
  void set_min_range(::google::protobuf::int64 value);

  // int64 max_range = 2;
  void clear_max_range();
  static const int kMaxRangeFieldNumber = 2;
  ::google::protobuf::int64 max_range() const;
  void set_max_range(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:meta_server.PartitionLocationRequest.Range)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 min_range_;
  ::google::protobuf::int64 max_range_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_meta_5fserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PartitionLocationRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:meta_server.PartitionLocationRequest) */ {
 public:
  PartitionLocationRequest();
  virtual ~PartitionLocationRequest();

  PartitionLocationRequest(const PartitionLocationRequest& from);

  inline PartitionLocationRequest& operator=(const PartitionLocationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PartitionLocationRequest(PartitionLocationRequest&& from) noexcept
    : PartitionLocationRequest() {
    *this = ::std::move(from);
  }

  inline PartitionLocationRequest& operator=(PartitionLocationRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PartitionLocationRequest& default_instance();

  enum PartitionValCase {
    kPartitionRange = 4,
    kHashVal = 5,
    PARTITION_VAL_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartitionLocationRequest* internal_default_instance() {
    return reinterpret_cast<const PartitionLocationRequest*>(
               &_PartitionLocationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(PartitionLocationRequest* other);
  friend void swap(PartitionLocationRequest& a, PartitionLocationRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PartitionLocationRequest* New() const final {
    return CreateMaybeMessage<PartitionLocationRequest>(NULL);
  }

  PartitionLocationRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PartitionLocationRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PartitionLocationRequest& from);
  void MergeFrom(const PartitionLocationRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionLocationRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PartitionLocationRequest_Range Range;

  // accessors -------------------------------------------------------

  // string db_name = 1;
  void clear_db_name();
  static const int kDbNameFieldNumber = 1;
  const ::std::string& db_name() const;
  void set_db_name(const ::std::string& value);
  #if LANG_CXX11
  void set_db_name(::std::string&& value);
  #endif
  void set_db_name(const char* value);
  void set_db_name(const char* value, size_t size);
  ::std::string* mutable_db_name();
  ::std::string* release_db_name();
  void set_allocated_db_name(::std::string* db_name);

  // string tab_name = 2;
  void clear_tab_name();
  static const int kTabNameFieldNumber = 2;
  const ::std::string& tab_name() const;
  void set_tab_name(const ::std::string& value);
  #if LANG_CXX11
  void set_tab_name(::std::string&& value);
  #endif
  void set_tab_name(const char* value);
  void set_tab_name(const char* value, size_t size);
  ::std::string* mutable_tab_name();
  ::std::string* release_tab_name();
  void set_allocated_tab_name(::std::string* tab_name);

  // string partition_key_name = 3;
  void clear_partition_key_name();
  static const int kPartitionKeyNameFieldNumber = 3;
  const ::std::string& partition_key_name() const;
  void set_partition_key_name(const ::std::string& value);
  #if LANG_CXX11
  void set_partition_key_name(::std::string&& value);
  #endif
  void set_partition_key_name(const char* value);
  void set_partition_key_name(const char* value, size_t size);
  ::std::string* mutable_partition_key_name();
  ::std::string* release_partition_key_name();
  void set_allocated_partition_key_name(::std::string* partition_key_name);

  // .meta_server.PartitionLocationRequest.Range partition_range = 4;
  bool has_partition_range() const;
  void clear_partition_range();
  static const int kPartitionRangeFieldNumber = 4;
  private:
  const ::meta_server::PartitionLocationRequest_Range& _internal_partition_range() const;
  public:
  const ::meta_server::PartitionLocationRequest_Range& partition_range() const;
  ::meta_server::PartitionLocationRequest_Range* release_partition_range();
  ::meta_server::PartitionLocationRequest_Range* mutable_partition_range();
  void set_allocated_partition_range(::meta_server::PartitionLocationRequest_Range* partition_range);

  // int64 hash_val = 5;
  private:
  bool has_hash_val() const;
  public:
  void clear_hash_val();
  static const int kHashValFieldNumber = 5;
  ::google::protobuf::int64 hash_val() const;
  void set_hash_val(::google::protobuf::int64 value);

  void clear_partition_val();
  PartitionValCase partition_val_case() const;
  // @@protoc_insertion_point(class_scope:meta_server.PartitionLocationRequest)
 private:
  void set_has_partition_range();
  void set_has_hash_val();

  inline bool has_partition_val() const;
  inline void clear_has_partition_val();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr db_name_;
  ::google::protobuf::internal::ArenaStringPtr tab_name_;
  ::google::protobuf::internal::ArenaStringPtr partition_key_name_;
  union PartitionValUnion {
    PartitionValUnion() {}
    ::meta_server::PartitionLocationRequest_Range* partition_range_;
    ::google::protobuf::int64 hash_val_;
  } partition_val_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_meta_5fserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PartitionLocationResponse_ReplicaLocation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:meta_server.PartitionLocationResponse.ReplicaLocation) */ {
 public:
  PartitionLocationResponse_ReplicaLocation();
  virtual ~PartitionLocationResponse_ReplicaLocation();

  PartitionLocationResponse_ReplicaLocation(const PartitionLocationResponse_ReplicaLocation& from);

  inline PartitionLocationResponse_ReplicaLocation& operator=(const PartitionLocationResponse_ReplicaLocation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PartitionLocationResponse_ReplicaLocation(PartitionLocationResponse_ReplicaLocation&& from) noexcept
    : PartitionLocationResponse_ReplicaLocation() {
    *this = ::std::move(from);
  }

  inline PartitionLocationResponse_ReplicaLocation& operator=(PartitionLocationResponse_ReplicaLocation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PartitionLocationResponse_ReplicaLocation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartitionLocationResponse_ReplicaLocation* internal_default_instance() {
    return reinterpret_cast<const PartitionLocationResponse_ReplicaLocation*>(
               &_PartitionLocationResponse_ReplicaLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(PartitionLocationResponse_ReplicaLocation* other);
  friend void swap(PartitionLocationResponse_ReplicaLocation& a, PartitionLocationResponse_ReplicaLocation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PartitionLocationResponse_ReplicaLocation* New() const final {
    return CreateMaybeMessage<PartitionLocationResponse_ReplicaLocation>(NULL);
  }

  PartitionLocationResponse_ReplicaLocation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PartitionLocationResponse_ReplicaLocation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PartitionLocationResponse_ReplicaLocation& from);
  void MergeFrom(const PartitionLocationResponse_ReplicaLocation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionLocationResponse_ReplicaLocation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ip_addr = 1;
  void clear_ip_addr();
  static const int kIpAddrFieldNumber = 1;
  const ::std::string& ip_addr() const;
  void set_ip_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_ip_addr(::std::string&& value);
  #endif
  void set_ip_addr(const char* value);
  void set_ip_addr(const char* value, size_t size);
  ::std::string* mutable_ip_addr();
  ::std::string* release_ip_addr();
  void set_allocated_ip_addr(::std::string* ip_addr);

  // sint32 port = 2;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:meta_server.PartitionLocationResponse.ReplicaLocation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ip_addr_;
  ::google::protobuf::int32 port_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_meta_5fserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PartitionLocationResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:meta_server.PartitionLocationResponse) */ {
 public:
  PartitionLocationResponse();
  virtual ~PartitionLocationResponse();

  PartitionLocationResponse(const PartitionLocationResponse& from);

  inline PartitionLocationResponse& operator=(const PartitionLocationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PartitionLocationResponse(PartitionLocationResponse&& from) noexcept
    : PartitionLocationResponse() {
    *this = ::std::move(from);
  }

  inline PartitionLocationResponse& operator=(PartitionLocationResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PartitionLocationResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartitionLocationResponse* internal_default_instance() {
    return reinterpret_cast<const PartitionLocationResponse*>(
               &_PartitionLocationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(PartitionLocationResponse* other);
  friend void swap(PartitionLocationResponse& a, PartitionLocationResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PartitionLocationResponse* New() const final {
    return CreateMaybeMessage<PartitionLocationResponse>(NULL);
  }

  PartitionLocationResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PartitionLocationResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PartitionLocationResponse& from);
  void MergeFrom(const PartitionLocationResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionLocationResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PartitionLocationResponse_ReplicaLocation ReplicaLocation;

  // accessors -------------------------------------------------------

  // repeated sint32 p_id = 2;
  int p_id_size() const;
  void clear_p_id();
  static const int kPIdFieldNumber = 2;
  ::google::protobuf::int32 p_id(int index) const;
  void set_p_id(int index, ::google::protobuf::int32 value);
  void add_p_id(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      p_id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_p_id();

  // repeated .meta_server.PartitionLocationResponse.ReplicaLocation partition_location = 3;
  int partition_location_size() const;
  void clear_partition_location();
  static const int kPartitionLocationFieldNumber = 3;
  ::meta_server::PartitionLocationResponse_ReplicaLocation* mutable_partition_location(int index);
  ::google::protobuf::RepeatedPtrField< ::meta_server::PartitionLocationResponse_ReplicaLocation >*
      mutable_partition_location();
  const ::meta_server::PartitionLocationResponse_ReplicaLocation& partition_location(int index) const;
  ::meta_server::PartitionLocationResponse_ReplicaLocation* add_partition_location();
  const ::google::protobuf::RepeatedPtrField< ::meta_server::PartitionLocationResponse_ReplicaLocation >&
      partition_location() const;

  // sint32 partition_cnt = 1;
  void clear_partition_cnt();
  static const int kPartitionCntFieldNumber = 1;
  ::google::protobuf::int32 partition_cnt() const;
  void set_partition_cnt(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:meta_server.PartitionLocationResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > p_id_;
  mutable int _p_id_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::meta_server::PartitionLocationResponse_ReplicaLocation > partition_location_;
  ::google::protobuf::int32 partition_cnt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_meta_5fserver_2eproto::TableStruct;
};
// ===================================================================

class MetaService_Stub;

class MetaService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline MetaService() {};
 public:
  virtual ~MetaService();

  typedef MetaService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void GetPartitionKey(::google::protobuf::RpcController* controller,
                       const ::meta_server::PartionkeyNameRequest* request,
                       ::meta_server::PartionkeyNameResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void GetPartitionLocation(::google::protobuf::RpcController* controller,
                       const ::meta_server::PartitionLocationRequest* request,
                       ::meta_server::PartitionLocationResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MetaService);
};

class MetaService_Stub : public MetaService {
 public:
  MetaService_Stub(::google::protobuf::RpcChannel* channel);
  MetaService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~MetaService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements MetaService ------------------------------------------

  void GetPartitionKey(::google::protobuf::RpcController* controller,
                       const ::meta_server::PartionkeyNameRequest* request,
                       ::meta_server::PartionkeyNameResponse* response,
                       ::google::protobuf::Closure* done);
  void GetPartitionLocation(::google::protobuf::RpcController* controller,
                       const ::meta_server::PartitionLocationRequest* request,
                       ::meta_server::PartitionLocationResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MetaService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PartionkeyNameRequest

// string db_name = 1;
inline void PartionkeyNameRequest::clear_db_name() {
  db_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PartionkeyNameRequest::db_name() const {
  // @@protoc_insertion_point(field_get:meta_server.PartionkeyNameRequest.db_name)
  return db_name_.GetNoArena();
}
inline void PartionkeyNameRequest::set_db_name(const ::std::string& value) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:meta_server.PartionkeyNameRequest.db_name)
}
#if LANG_CXX11
inline void PartionkeyNameRequest::set_db_name(::std::string&& value) {
  
  db_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:meta_server.PartionkeyNameRequest.db_name)
}
#endif
inline void PartionkeyNameRequest::set_db_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:meta_server.PartionkeyNameRequest.db_name)
}
inline void PartionkeyNameRequest::set_db_name(const char* value, size_t size) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:meta_server.PartionkeyNameRequest.db_name)
}
inline ::std::string* PartionkeyNameRequest::mutable_db_name() {
  
  // @@protoc_insertion_point(field_mutable:meta_server.PartionkeyNameRequest.db_name)
  return db_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartionkeyNameRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:meta_server.PartionkeyNameRequest.db_name)
  
  return db_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartionkeyNameRequest::set_allocated_db_name(::std::string* db_name) {
  if (db_name != NULL) {
    
  } else {
    
  }
  db_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_name);
  // @@protoc_insertion_point(field_set_allocated:meta_server.PartionkeyNameRequest.db_name)
}

// string tab_name = 2;
inline void PartionkeyNameRequest::clear_tab_name() {
  tab_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PartionkeyNameRequest::tab_name() const {
  // @@protoc_insertion_point(field_get:meta_server.PartionkeyNameRequest.tab_name)
  return tab_name_.GetNoArena();
}
inline void PartionkeyNameRequest::set_tab_name(const ::std::string& value) {
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:meta_server.PartionkeyNameRequest.tab_name)
}
#if LANG_CXX11
inline void PartionkeyNameRequest::set_tab_name(::std::string&& value) {
  
  tab_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:meta_server.PartionkeyNameRequest.tab_name)
}
#endif
inline void PartionkeyNameRequest::set_tab_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:meta_server.PartionkeyNameRequest.tab_name)
}
inline void PartionkeyNameRequest::set_tab_name(const char* value, size_t size) {
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:meta_server.PartionkeyNameRequest.tab_name)
}
inline ::std::string* PartionkeyNameRequest::mutable_tab_name() {
  
  // @@protoc_insertion_point(field_mutable:meta_server.PartionkeyNameRequest.tab_name)
  return tab_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartionkeyNameRequest::release_tab_name() {
  // @@protoc_insertion_point(field_release:meta_server.PartionkeyNameRequest.tab_name)
  
  return tab_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartionkeyNameRequest::set_allocated_tab_name(::std::string* tab_name) {
  if (tab_name != NULL) {
    
  } else {
    
  }
  tab_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tab_name);
  // @@protoc_insertion_point(field_set_allocated:meta_server.PartionkeyNameRequest.tab_name)
}

// -------------------------------------------------------------------

// PartionkeyNameResponse

// string partition_key_name = 1;
inline void PartionkeyNameResponse::clear_partition_key_name() {
  partition_key_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PartionkeyNameResponse::partition_key_name() const {
  // @@protoc_insertion_point(field_get:meta_server.PartionkeyNameResponse.partition_key_name)
  return partition_key_name_.GetNoArena();
}
inline void PartionkeyNameResponse::set_partition_key_name(const ::std::string& value) {
  
  partition_key_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:meta_server.PartionkeyNameResponse.partition_key_name)
}
#if LANG_CXX11
inline void PartionkeyNameResponse::set_partition_key_name(::std::string&& value) {
  
  partition_key_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:meta_server.PartionkeyNameResponse.partition_key_name)
}
#endif
inline void PartionkeyNameResponse::set_partition_key_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  partition_key_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:meta_server.PartionkeyNameResponse.partition_key_name)
}
inline void PartionkeyNameResponse::set_partition_key_name(const char* value, size_t size) {
  
  partition_key_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:meta_server.PartionkeyNameResponse.partition_key_name)
}
inline ::std::string* PartionkeyNameResponse::mutable_partition_key_name() {
  
  // @@protoc_insertion_point(field_mutable:meta_server.PartionkeyNameResponse.partition_key_name)
  return partition_key_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartionkeyNameResponse::release_partition_key_name() {
  // @@protoc_insertion_point(field_release:meta_server.PartionkeyNameResponse.partition_key_name)
  
  return partition_key_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartionkeyNameResponse::set_allocated_partition_key_name(::std::string* partition_key_name) {
  if (partition_key_name != NULL) {
    
  } else {
    
  }
  partition_key_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), partition_key_name);
  // @@protoc_insertion_point(field_set_allocated:meta_server.PartionkeyNameResponse.partition_key_name)
}

// -------------------------------------------------------------------

// PartitionLocationRequest_Range

// int64 min_range = 1;
inline void PartitionLocationRequest_Range::clear_min_range() {
  min_range_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PartitionLocationRequest_Range::min_range() const {
  // @@protoc_insertion_point(field_get:meta_server.PartitionLocationRequest.Range.min_range)
  return min_range_;
}
inline void PartitionLocationRequest_Range::set_min_range(::google::protobuf::int64 value) {
  
  min_range_ = value;
  // @@protoc_insertion_point(field_set:meta_server.PartitionLocationRequest.Range.min_range)
}

// int64 max_range = 2;
inline void PartitionLocationRequest_Range::clear_max_range() {
  max_range_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PartitionLocationRequest_Range::max_range() const {
  // @@protoc_insertion_point(field_get:meta_server.PartitionLocationRequest.Range.max_range)
  return max_range_;
}
inline void PartitionLocationRequest_Range::set_max_range(::google::protobuf::int64 value) {
  
  max_range_ = value;
  // @@protoc_insertion_point(field_set:meta_server.PartitionLocationRequest.Range.max_range)
}

// -------------------------------------------------------------------

// PartitionLocationRequest

// string db_name = 1;
inline void PartitionLocationRequest::clear_db_name() {
  db_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PartitionLocationRequest::db_name() const {
  // @@protoc_insertion_point(field_get:meta_server.PartitionLocationRequest.db_name)
  return db_name_.GetNoArena();
}
inline void PartitionLocationRequest::set_db_name(const ::std::string& value) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:meta_server.PartitionLocationRequest.db_name)
}
#if LANG_CXX11
inline void PartitionLocationRequest::set_db_name(::std::string&& value) {
  
  db_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:meta_server.PartitionLocationRequest.db_name)
}
#endif
inline void PartitionLocationRequest::set_db_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:meta_server.PartitionLocationRequest.db_name)
}
inline void PartitionLocationRequest::set_db_name(const char* value, size_t size) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:meta_server.PartitionLocationRequest.db_name)
}
inline ::std::string* PartitionLocationRequest::mutable_db_name() {
  
  // @@protoc_insertion_point(field_mutable:meta_server.PartitionLocationRequest.db_name)
  return db_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionLocationRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:meta_server.PartitionLocationRequest.db_name)
  
  return db_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionLocationRequest::set_allocated_db_name(::std::string* db_name) {
  if (db_name != NULL) {
    
  } else {
    
  }
  db_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_name);
  // @@protoc_insertion_point(field_set_allocated:meta_server.PartitionLocationRequest.db_name)
}

// string tab_name = 2;
inline void PartitionLocationRequest::clear_tab_name() {
  tab_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PartitionLocationRequest::tab_name() const {
  // @@protoc_insertion_point(field_get:meta_server.PartitionLocationRequest.tab_name)
  return tab_name_.GetNoArena();
}
inline void PartitionLocationRequest::set_tab_name(const ::std::string& value) {
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:meta_server.PartitionLocationRequest.tab_name)
}
#if LANG_CXX11
inline void PartitionLocationRequest::set_tab_name(::std::string&& value) {
  
  tab_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:meta_server.PartitionLocationRequest.tab_name)
}
#endif
inline void PartitionLocationRequest::set_tab_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:meta_server.PartitionLocationRequest.tab_name)
}
inline void PartitionLocationRequest::set_tab_name(const char* value, size_t size) {
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:meta_server.PartitionLocationRequest.tab_name)
}
inline ::std::string* PartitionLocationRequest::mutable_tab_name() {
  
  // @@protoc_insertion_point(field_mutable:meta_server.PartitionLocationRequest.tab_name)
  return tab_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionLocationRequest::release_tab_name() {
  // @@protoc_insertion_point(field_release:meta_server.PartitionLocationRequest.tab_name)
  
  return tab_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionLocationRequest::set_allocated_tab_name(::std::string* tab_name) {
  if (tab_name != NULL) {
    
  } else {
    
  }
  tab_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tab_name);
  // @@protoc_insertion_point(field_set_allocated:meta_server.PartitionLocationRequest.tab_name)
}

// string partition_key_name = 3;
inline void PartitionLocationRequest::clear_partition_key_name() {
  partition_key_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PartitionLocationRequest::partition_key_name() const {
  // @@protoc_insertion_point(field_get:meta_server.PartitionLocationRequest.partition_key_name)
  return partition_key_name_.GetNoArena();
}
inline void PartitionLocationRequest::set_partition_key_name(const ::std::string& value) {
  
  partition_key_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:meta_server.PartitionLocationRequest.partition_key_name)
}
#if LANG_CXX11
inline void PartitionLocationRequest::set_partition_key_name(::std::string&& value) {
  
  partition_key_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:meta_server.PartitionLocationRequest.partition_key_name)
}
#endif
inline void PartitionLocationRequest::set_partition_key_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  partition_key_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:meta_server.PartitionLocationRequest.partition_key_name)
}
inline void PartitionLocationRequest::set_partition_key_name(const char* value, size_t size) {
  
  partition_key_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:meta_server.PartitionLocationRequest.partition_key_name)
}
inline ::std::string* PartitionLocationRequest::mutable_partition_key_name() {
  
  // @@protoc_insertion_point(field_mutable:meta_server.PartitionLocationRequest.partition_key_name)
  return partition_key_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionLocationRequest::release_partition_key_name() {
  // @@protoc_insertion_point(field_release:meta_server.PartitionLocationRequest.partition_key_name)
  
  return partition_key_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionLocationRequest::set_allocated_partition_key_name(::std::string* partition_key_name) {
  if (partition_key_name != NULL) {
    
  } else {
    
  }
  partition_key_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), partition_key_name);
  // @@protoc_insertion_point(field_set_allocated:meta_server.PartitionLocationRequest.partition_key_name)
}

// .meta_server.PartitionLocationRequest.Range partition_range = 4;
inline bool PartitionLocationRequest::has_partition_range() const {
  return partition_val_case() == kPartitionRange;
}
inline void PartitionLocationRequest::set_has_partition_range() {
  _oneof_case_[0] = kPartitionRange;
}
inline void PartitionLocationRequest::clear_partition_range() {
  if (has_partition_range()) {
    delete partition_val_.partition_range_;
    clear_has_partition_val();
  }
}
inline const ::meta_server::PartitionLocationRequest_Range& PartitionLocationRequest::_internal_partition_range() const {
  return *partition_val_.partition_range_;
}
inline ::meta_server::PartitionLocationRequest_Range* PartitionLocationRequest::release_partition_range() {
  // @@protoc_insertion_point(field_release:meta_server.PartitionLocationRequest.partition_range)
  if (has_partition_range()) {
    clear_has_partition_val();
      ::meta_server::PartitionLocationRequest_Range* temp = partition_val_.partition_range_;
    partition_val_.partition_range_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::meta_server::PartitionLocationRequest_Range& PartitionLocationRequest::partition_range() const {
  // @@protoc_insertion_point(field_get:meta_server.PartitionLocationRequest.partition_range)
  return has_partition_range()
      ? *partition_val_.partition_range_
      : *reinterpret_cast< ::meta_server::PartitionLocationRequest_Range*>(&::meta_server::_PartitionLocationRequest_Range_default_instance_);
}
inline ::meta_server::PartitionLocationRequest_Range* PartitionLocationRequest::mutable_partition_range() {
  if (!has_partition_range()) {
    clear_partition_val();
    set_has_partition_range();
    partition_val_.partition_range_ = CreateMaybeMessage< ::meta_server::PartitionLocationRequest_Range >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:meta_server.PartitionLocationRequest.partition_range)
  return partition_val_.partition_range_;
}

// int64 hash_val = 5;
inline bool PartitionLocationRequest::has_hash_val() const {
  return partition_val_case() == kHashVal;
}
inline void PartitionLocationRequest::set_has_hash_val() {
  _oneof_case_[0] = kHashVal;
}
inline void PartitionLocationRequest::clear_hash_val() {
  if (has_hash_val()) {
    partition_val_.hash_val_ = GOOGLE_LONGLONG(0);
    clear_has_partition_val();
  }
}
inline ::google::protobuf::int64 PartitionLocationRequest::hash_val() const {
  // @@protoc_insertion_point(field_get:meta_server.PartitionLocationRequest.hash_val)
  if (has_hash_val()) {
    return partition_val_.hash_val_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void PartitionLocationRequest::set_hash_val(::google::protobuf::int64 value) {
  if (!has_hash_val()) {
    clear_partition_val();
    set_has_hash_val();
  }
  partition_val_.hash_val_ = value;
  // @@protoc_insertion_point(field_set:meta_server.PartitionLocationRequest.hash_val)
}

inline bool PartitionLocationRequest::has_partition_val() const {
  return partition_val_case() != PARTITION_VAL_NOT_SET;
}
inline void PartitionLocationRequest::clear_has_partition_val() {
  _oneof_case_[0] = PARTITION_VAL_NOT_SET;
}
inline PartitionLocationRequest::PartitionValCase PartitionLocationRequest::partition_val_case() const {
  return PartitionLocationRequest::PartitionValCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PartitionLocationResponse_ReplicaLocation

// string ip_addr = 1;
inline void PartitionLocationResponse_ReplicaLocation::clear_ip_addr() {
  ip_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PartitionLocationResponse_ReplicaLocation::ip_addr() const {
  // @@protoc_insertion_point(field_get:meta_server.PartitionLocationResponse.ReplicaLocation.ip_addr)
  return ip_addr_.GetNoArena();
}
inline void PartitionLocationResponse_ReplicaLocation::set_ip_addr(const ::std::string& value) {
  
  ip_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:meta_server.PartitionLocationResponse.ReplicaLocation.ip_addr)
}
#if LANG_CXX11
inline void PartitionLocationResponse_ReplicaLocation::set_ip_addr(::std::string&& value) {
  
  ip_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:meta_server.PartitionLocationResponse.ReplicaLocation.ip_addr)
}
#endif
inline void PartitionLocationResponse_ReplicaLocation::set_ip_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:meta_server.PartitionLocationResponse.ReplicaLocation.ip_addr)
}
inline void PartitionLocationResponse_ReplicaLocation::set_ip_addr(const char* value, size_t size) {
  
  ip_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:meta_server.PartitionLocationResponse.ReplicaLocation.ip_addr)
}
inline ::std::string* PartitionLocationResponse_ReplicaLocation::mutable_ip_addr() {
  
  // @@protoc_insertion_point(field_mutable:meta_server.PartitionLocationResponse.ReplicaLocation.ip_addr)
  return ip_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionLocationResponse_ReplicaLocation::release_ip_addr() {
  // @@protoc_insertion_point(field_release:meta_server.PartitionLocationResponse.ReplicaLocation.ip_addr)
  
  return ip_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionLocationResponse_ReplicaLocation::set_allocated_ip_addr(::std::string* ip_addr) {
  if (ip_addr != NULL) {
    
  } else {
    
  }
  ip_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_addr);
  // @@protoc_insertion_point(field_set_allocated:meta_server.PartitionLocationResponse.ReplicaLocation.ip_addr)
}

// sint32 port = 2;
inline void PartitionLocationResponse_ReplicaLocation::clear_port() {
  port_ = 0;
}
inline ::google::protobuf::int32 PartitionLocationResponse_ReplicaLocation::port() const {
  // @@protoc_insertion_point(field_get:meta_server.PartitionLocationResponse.ReplicaLocation.port)
  return port_;
}
inline void PartitionLocationResponse_ReplicaLocation::set_port(::google::protobuf::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:meta_server.PartitionLocationResponse.ReplicaLocation.port)
}

// -------------------------------------------------------------------

// PartitionLocationResponse

// sint32 partition_cnt = 1;
inline void PartitionLocationResponse::clear_partition_cnt() {
  partition_cnt_ = 0;
}
inline ::google::protobuf::int32 PartitionLocationResponse::partition_cnt() const {
  // @@protoc_insertion_point(field_get:meta_server.PartitionLocationResponse.partition_cnt)
  return partition_cnt_;
}
inline void PartitionLocationResponse::set_partition_cnt(::google::protobuf::int32 value) {
  
  partition_cnt_ = value;
  // @@protoc_insertion_point(field_set:meta_server.PartitionLocationResponse.partition_cnt)
}

// repeated sint32 p_id = 2;
inline int PartitionLocationResponse::p_id_size() const {
  return p_id_.size();
}
inline void PartitionLocationResponse::clear_p_id() {
  p_id_.Clear();
}
inline ::google::protobuf::int32 PartitionLocationResponse::p_id(int index) const {
  // @@protoc_insertion_point(field_get:meta_server.PartitionLocationResponse.p_id)
  return p_id_.Get(index);
}
inline void PartitionLocationResponse::set_p_id(int index, ::google::protobuf::int32 value) {
  p_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:meta_server.PartitionLocationResponse.p_id)
}
inline void PartitionLocationResponse::add_p_id(::google::protobuf::int32 value) {
  p_id_.Add(value);
  // @@protoc_insertion_point(field_add:meta_server.PartitionLocationResponse.p_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PartitionLocationResponse::p_id() const {
  // @@protoc_insertion_point(field_list:meta_server.PartitionLocationResponse.p_id)
  return p_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PartitionLocationResponse::mutable_p_id() {
  // @@protoc_insertion_point(field_mutable_list:meta_server.PartitionLocationResponse.p_id)
  return &p_id_;
}

// repeated .meta_server.PartitionLocationResponse.ReplicaLocation partition_location = 3;
inline int PartitionLocationResponse::partition_location_size() const {
  return partition_location_.size();
}
inline void PartitionLocationResponse::clear_partition_location() {
  partition_location_.Clear();
}
inline ::meta_server::PartitionLocationResponse_ReplicaLocation* PartitionLocationResponse::mutable_partition_location(int index) {
  // @@protoc_insertion_point(field_mutable:meta_server.PartitionLocationResponse.partition_location)
  return partition_location_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::meta_server::PartitionLocationResponse_ReplicaLocation >*
PartitionLocationResponse::mutable_partition_location() {
  // @@protoc_insertion_point(field_mutable_list:meta_server.PartitionLocationResponse.partition_location)
  return &partition_location_;
}
inline const ::meta_server::PartitionLocationResponse_ReplicaLocation& PartitionLocationResponse::partition_location(int index) const {
  // @@protoc_insertion_point(field_get:meta_server.PartitionLocationResponse.partition_location)
  return partition_location_.Get(index);
}
inline ::meta_server::PartitionLocationResponse_ReplicaLocation* PartitionLocationResponse::add_partition_location() {
  // @@protoc_insertion_point(field_add:meta_server.PartitionLocationResponse.partition_location)
  return partition_location_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::meta_server::PartitionLocationResponse_ReplicaLocation >&
PartitionLocationResponse::partition_location() const {
  // @@protoc_insertion_point(field_list:meta_server.PartitionLocationResponse.partition_location)
  return partition_location_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace meta_server

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_meta_5fserver_2eproto
