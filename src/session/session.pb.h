// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: session.proto

#ifndef PROTOBUF_INCLUDED_session_2eproto
#define PROTOBUF_INCLUDED_session_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_session_2eproto 

namespace protobuf_session_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[19];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_session_2eproto
namespace session {
class ChildPlan;
class ChildPlanDefaultTypeInternal;
extern ChildPlanDefaultTypeInternal _ChildPlan_default_instance_;
class DeletePlan;
class DeletePlanDefaultTypeInternal;
extern DeletePlanDefaultTypeInternal _DeletePlan_default_instance_;
class DistributedPlan;
class DistributedPlanDefaultTypeInternal;
extern DistributedPlanDefaultTypeInternal _DistributedPlan_default_instance_;
class DistributedPlan_Node;
class DistributedPlan_NodeDefaultTypeInternal;
extern DistributedPlan_NodeDefaultTypeInternal _DistributedPlan_Node_default_instance_;
class Expression;
class ExpressionDefaultTypeInternal;
extern ExpressionDefaultTypeInternal _Expression_default_instance_;
class FilterPlan;
class FilterPlanDefaultTypeInternal;
extern FilterPlanDefaultTypeInternal _FilterPlan_default_instance_;
class InsertPlan;
class InsertPlanDefaultTypeInternal;
extern InsertPlanDefaultTypeInternal _InsertPlan_default_instance_;
class NestedLoopJoin;
class NestedLoopJoinDefaultTypeInternal;
extern NestedLoopJoinDefaultTypeInternal _NestedLoopJoin_default_instance_;
class ProjectionPlan;
class ProjectionPlanDefaultTypeInternal;
extern ProjectionPlanDefaultTypeInternal _ProjectionPlan_default_instance_;
class RemotePlan;
class RemotePlanDefaultTypeInternal;
extern RemotePlanDefaultTypeInternal _RemotePlan_default_instance_;
class SQL_Request;
class SQL_RequestDefaultTypeInternal;
extern SQL_RequestDefaultTypeInternal _SQL_Request_default_instance_;
class SQL_Response;
class SQL_ResponseDefaultTypeInternal;
extern SQL_ResponseDefaultTypeInternal _SQL_Response_default_instance_;
class SeqScanPlan;
class SeqScanPlanDefaultTypeInternal;
extern SeqScanPlanDefaultTypeInternal _SeqScanPlan_default_instance_;
class Table;
class TableDefaultTypeInternal;
extern TableDefaultTypeInternal _Table_default_instance_;
class TableGetPlan;
class TableGetPlanDefaultTypeInternal;
extern TableGetPlanDefaultTypeInternal _TableGetPlan_default_instance_;
class Tuple;
class TupleDefaultTypeInternal;
extern TupleDefaultTypeInternal _Tuple_default_instance_;
class UpdatePlan;
class UpdatePlanDefaultTypeInternal;
extern UpdatePlanDefaultTypeInternal _UpdatePlan_default_instance_;
class Value;
class ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
class ValuePlan;
class ValuePlanDefaultTypeInternal;
extern ValuePlanDefaultTypeInternal _ValuePlan_default_instance_;
}  // namespace session
namespace google {
namespace protobuf {
template<> ::session::ChildPlan* Arena::CreateMaybeMessage<::session::ChildPlan>(Arena*);
template<> ::session::DeletePlan* Arena::CreateMaybeMessage<::session::DeletePlan>(Arena*);
template<> ::session::DistributedPlan* Arena::CreateMaybeMessage<::session::DistributedPlan>(Arena*);
template<> ::session::DistributedPlan_Node* Arena::CreateMaybeMessage<::session::DistributedPlan_Node>(Arena*);
template<> ::session::Expression* Arena::CreateMaybeMessage<::session::Expression>(Arena*);
template<> ::session::FilterPlan* Arena::CreateMaybeMessage<::session::FilterPlan>(Arena*);
template<> ::session::InsertPlan* Arena::CreateMaybeMessage<::session::InsertPlan>(Arena*);
template<> ::session::NestedLoopJoin* Arena::CreateMaybeMessage<::session::NestedLoopJoin>(Arena*);
template<> ::session::ProjectionPlan* Arena::CreateMaybeMessage<::session::ProjectionPlan>(Arena*);
template<> ::session::RemotePlan* Arena::CreateMaybeMessage<::session::RemotePlan>(Arena*);
template<> ::session::SQL_Request* Arena::CreateMaybeMessage<::session::SQL_Request>(Arena*);
template<> ::session::SQL_Response* Arena::CreateMaybeMessage<::session::SQL_Response>(Arena*);
template<> ::session::SeqScanPlan* Arena::CreateMaybeMessage<::session::SeqScanPlan>(Arena*);
template<> ::session::Table* Arena::CreateMaybeMessage<::session::Table>(Arena*);
template<> ::session::TableGetPlan* Arena::CreateMaybeMessage<::session::TableGetPlan>(Arena*);
template<> ::session::Tuple* Arena::CreateMaybeMessage<::session::Tuple>(Arena*);
template<> ::session::UpdatePlan* Arena::CreateMaybeMessage<::session::UpdatePlan>(Arena*);
template<> ::session::Value* Arena::CreateMaybeMessage<::session::Value>(Arena*);
template<> ::session::ValuePlan* Arena::CreateMaybeMessage<::session::ValuePlan>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace session {

enum JoinType {
  INVALID = 0,
  LEFT = 1,
  RIGHT = 3,
  INNER = 4,
  OUTER = 5,
  JoinType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  JoinType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool JoinType_IsValid(int value);
const JoinType JoinType_MIN = INVALID;
const JoinType JoinType_MAX = OUTER;
const int JoinType_ARRAYSIZE = JoinType_MAX + 1;

const ::google::protobuf::EnumDescriptor* JoinType_descriptor();
inline const ::std::string& JoinType_Name(JoinType value) {
  return ::google::protobuf::internal::NameOfEnum(
    JoinType_descriptor(), value);
}
inline bool JoinType_Parse(
    const ::std::string& name, JoinType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<JoinType>(
    JoinType_descriptor(), name, value);
}
// ===================================================================

class Value : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:session.Value) */ {
 public:
  Value();
  virtual ~Value();

  Value(const Value& from);

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(Value&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Value& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Value* other);
  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Value* New() const final {
    return CreateMaybeMessage<Value>(NULL);
  }

  Value* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Value* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // sint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:session.Value)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_session_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Tuple : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:session.Tuple) */ {
 public:
  Tuple();
  virtual ~Tuple();

  Tuple(const Tuple& from);

  inline Tuple& operator=(const Tuple& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Tuple(Tuple&& from) noexcept
    : Tuple() {
    *this = ::std::move(from);
  }

  inline Tuple& operator=(Tuple&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tuple& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tuple* internal_default_instance() {
    return reinterpret_cast<const Tuple*>(
               &_Tuple_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Tuple* other);
  friend void swap(Tuple& a, Tuple& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Tuple* New() const final {
    return CreateMaybeMessage<Tuple>(NULL);
  }

  Tuple* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Tuple>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Tuple& from);
  void MergeFrom(const Tuple& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tuple* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .session.Value tuple = 1;
  int tuple_size() const;
  void clear_tuple();
  static const int kTupleFieldNumber = 1;
  ::session::Value* mutable_tuple(int index);
  ::google::protobuf::RepeatedPtrField< ::session::Value >*
      mutable_tuple();
  const ::session::Value& tuple(int index) const;
  ::session::Value* add_tuple();
  const ::google::protobuf::RepeatedPtrField< ::session::Value >&
      tuple() const;

  // @@protoc_insertion_point(class_scope:session.Tuple)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::session::Value > tuple_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_session_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Table : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:session.Table) */ {
 public:
  Table();
  virtual ~Table();

  Table(const Table& from);

  inline Table& operator=(const Table& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Table(Table&& from) noexcept
    : Table() {
    *this = ::std::move(from);
  }

  inline Table& operator=(Table&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Table& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Table* internal_default_instance() {
    return reinterpret_cast<const Table*>(
               &_Table_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Table* other);
  friend void swap(Table& a, Table& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Table* New() const final {
    return CreateMaybeMessage<Table>(NULL);
  }

  Table* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Table>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Table& from);
  void MergeFrom(const Table& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Table* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .session.Tuple table = 1;
  int table_size() const;
  void clear_table();
  static const int kTableFieldNumber = 1;
  ::session::Tuple* mutable_table(int index);
  ::google::protobuf::RepeatedPtrField< ::session::Tuple >*
      mutable_table();
  const ::session::Tuple& table(int index) const;
  ::session::Tuple* add_table();
  const ::google::protobuf::RepeatedPtrField< ::session::Tuple >&
      table() const;

  // @@protoc_insertion_point(class_scope:session.Table)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::session::Tuple > table_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_session_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SQL_Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:session.SQL_Request) */ {
 public:
  SQL_Request();
  virtual ~SQL_Request();

  SQL_Request(const SQL_Request& from);

  inline SQL_Request& operator=(const SQL_Request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SQL_Request(SQL_Request&& from) noexcept
    : SQL_Request() {
    *this = ::std::move(from);
  }

  inline SQL_Request& operator=(SQL_Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SQL_Request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SQL_Request* internal_default_instance() {
    return reinterpret_cast<const SQL_Request*>(
               &_SQL_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SQL_Request* other);
  friend void swap(SQL_Request& a, SQL_Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SQL_Request* New() const final {
    return CreateMaybeMessage<SQL_Request>(NULL);
  }

  SQL_Request* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SQL_Request>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SQL_Request& from);
  void MergeFrom(const SQL_Request& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SQL_Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Sql_statement = 1;
  void clear_sql_statement();
  static const int kSqlStatementFieldNumber = 1;
  const ::std::string& sql_statement() const;
  void set_sql_statement(const ::std::string& value);
  #if LANG_CXX11
  void set_sql_statement(::std::string&& value);
  #endif
  void set_sql_statement(const char* value);
  void set_sql_statement(const char* value, size_t size);
  ::std::string* mutable_sql_statement();
  ::std::string* release_sql_statement();
  void set_allocated_sql_statement(::std::string* sql_statement);

  // @@protoc_insertion_point(class_scope:session.SQL_Request)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sql_statement_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_session_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SQL_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:session.SQL_Response) */ {
 public:
  SQL_Response();
  virtual ~SQL_Response();

  SQL_Response(const SQL_Response& from);

  inline SQL_Response& operator=(const SQL_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SQL_Response(SQL_Response&& from) noexcept
    : SQL_Response() {
    *this = ::std::move(from);
  }

  inline SQL_Response& operator=(SQL_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SQL_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SQL_Response* internal_default_instance() {
    return reinterpret_cast<const SQL_Response*>(
               &_SQL_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SQL_Response* other);
  friend void swap(SQL_Response& a, SQL_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SQL_Response* New() const final {
    return CreateMaybeMessage<SQL_Response>(NULL);
  }

  SQL_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SQL_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SQL_Response& from);
  void MergeFrom(const SQL_Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SQL_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .session.Table Sql_response = 1;
  bool has_sql_response() const;
  void clear_sql_response();
  static const int kSqlResponseFieldNumber = 1;
  private:
  const ::session::Table& _internal_sql_response() const;
  public:
  const ::session::Table& sql_response() const;
  ::session::Table* release_sql_response();
  ::session::Table* mutable_sql_response();
  void set_allocated_sql_response(::session::Table* sql_response);

  // @@protoc_insertion_point(class_scope:session.SQL_Response)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::session::Table* sql_response_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_session_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:session.Expression) */ {
 public:
  Expression();
  virtual ~Expression();

  Expression(const Expression& from);

  inline Expression& operator=(const Expression& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression(Expression&& from) noexcept
    : Expression() {
    *this = ::std::move(from);
  }

  inline Expression& operator=(Expression&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression* internal_default_instance() {
    return reinterpret_cast<const Expression*>(
               &_Expression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Expression* other);
  friend void swap(Expression& a, Expression& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression* New() const final {
    return CreateMaybeMessage<Expression>(NULL);
  }

  Expression* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression& from);
  void MergeFrom(const Expression& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string str_expression = 1;
  void clear_str_expression();
  static const int kStrExpressionFieldNumber = 1;
  const ::std::string& str_expression() const;
  void set_str_expression(const ::std::string& value);
  #if LANG_CXX11
  void set_str_expression(::std::string&& value);
  #endif
  void set_str_expression(const char* value);
  void set_str_expression(const char* value, size_t size);
  ::std::string* mutable_str_expression();
  ::std::string* release_str_expression();
  void set_allocated_str_expression(::std::string* str_expression);

  // @@protoc_insertion_point(class_scope:session.Expression)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr str_expression_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_session_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChildPlan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:session.ChildPlan) */ {
 public:
  ChildPlan();
  virtual ~ChildPlan();

  ChildPlan(const ChildPlan& from);

  inline ChildPlan& operator=(const ChildPlan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChildPlan(ChildPlan&& from) noexcept
    : ChildPlan() {
    *this = ::std::move(from);
  }

  inline ChildPlan& operator=(ChildPlan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChildPlan& default_instance();

  enum ChildPlanCase {
    kSeqScanPlan = 1,
    kFilterPlan = 2,
    kProjectPlan = 3,
    kInsertPlan = 4,
    kDeletePlan = 5,
    kUpdatePlan = 6,
    kNestedloopJoinPlan = 7,
    kValuePlan = 8,
    kTableGetPan = 9,
    kDistributedPlan = 10,
    CHILD_PLAN_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChildPlan* internal_default_instance() {
    return reinterpret_cast<const ChildPlan*>(
               &_ChildPlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ChildPlan* other);
  friend void swap(ChildPlan& a, ChildPlan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChildPlan* New() const final {
    return CreateMaybeMessage<ChildPlan>(NULL);
  }

  ChildPlan* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChildPlan>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChildPlan& from);
  void MergeFrom(const ChildPlan& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChildPlan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .session.SeqScanPlan seq_scan_plan = 1;
  bool has_seq_scan_plan() const;
  void clear_seq_scan_plan();
  static const int kSeqScanPlanFieldNumber = 1;
  private:
  const ::session::SeqScanPlan& _internal_seq_scan_plan() const;
  public:
  const ::session::SeqScanPlan& seq_scan_plan() const;
  ::session::SeqScanPlan* release_seq_scan_plan();
  ::session::SeqScanPlan* mutable_seq_scan_plan();
  void set_allocated_seq_scan_plan(::session::SeqScanPlan* seq_scan_plan);

  // .session.FilterPlan filter_plan = 2;
  bool has_filter_plan() const;
  void clear_filter_plan();
  static const int kFilterPlanFieldNumber = 2;
  private:
  const ::session::FilterPlan& _internal_filter_plan() const;
  public:
  const ::session::FilterPlan& filter_plan() const;
  ::session::FilterPlan* release_filter_plan();
  ::session::FilterPlan* mutable_filter_plan();
  void set_allocated_filter_plan(::session::FilterPlan* filter_plan);

  // .session.ProjectionPlan project_plan = 3;
  bool has_project_plan() const;
  void clear_project_plan();
  static const int kProjectPlanFieldNumber = 3;
  private:
  const ::session::ProjectionPlan& _internal_project_plan() const;
  public:
  const ::session::ProjectionPlan& project_plan() const;
  ::session::ProjectionPlan* release_project_plan();
  ::session::ProjectionPlan* mutable_project_plan();
  void set_allocated_project_plan(::session::ProjectionPlan* project_plan);

  // .session.InsertPlan insert_plan = 4;
  bool has_insert_plan() const;
  void clear_insert_plan();
  static const int kInsertPlanFieldNumber = 4;
  private:
  const ::session::InsertPlan& _internal_insert_plan() const;
  public:
  const ::session::InsertPlan& insert_plan() const;
  ::session::InsertPlan* release_insert_plan();
  ::session::InsertPlan* mutable_insert_plan();
  void set_allocated_insert_plan(::session::InsertPlan* insert_plan);

  // .session.DeletePlan delete_plan = 5;
  bool has_delete_plan() const;
  void clear_delete_plan();
  static const int kDeletePlanFieldNumber = 5;
  private:
  const ::session::DeletePlan& _internal_delete_plan() const;
  public:
  const ::session::DeletePlan& delete_plan() const;
  ::session::DeletePlan* release_delete_plan();
  ::session::DeletePlan* mutable_delete_plan();
  void set_allocated_delete_plan(::session::DeletePlan* delete_plan);

  // .session.UpdatePlan update_plan = 6;
  bool has_update_plan() const;
  void clear_update_plan();
  static const int kUpdatePlanFieldNumber = 6;
  private:
  const ::session::UpdatePlan& _internal_update_plan() const;
  public:
  const ::session::UpdatePlan& update_plan() const;
  ::session::UpdatePlan* release_update_plan();
  ::session::UpdatePlan* mutable_update_plan();
  void set_allocated_update_plan(::session::UpdatePlan* update_plan);

  // .session.NestedLoopJoin nestedloop_join_plan = 7;
  bool has_nestedloop_join_plan() const;
  void clear_nestedloop_join_plan();
  static const int kNestedloopJoinPlanFieldNumber = 7;
  private:
  const ::session::NestedLoopJoin& _internal_nestedloop_join_plan() const;
  public:
  const ::session::NestedLoopJoin& nestedloop_join_plan() const;
  ::session::NestedLoopJoin* release_nestedloop_join_plan();
  ::session::NestedLoopJoin* mutable_nestedloop_join_plan();
  void set_allocated_nestedloop_join_plan(::session::NestedLoopJoin* nestedloop_join_plan);

  // .session.ValuePlan value_plan = 8;
  bool has_value_plan() const;
  void clear_value_plan();
  static const int kValuePlanFieldNumber = 8;
  private:
  const ::session::ValuePlan& _internal_value_plan() const;
  public:
  const ::session::ValuePlan& value_plan() const;
  ::session::ValuePlan* release_value_plan();
  ::session::ValuePlan* mutable_value_plan();
  void set_allocated_value_plan(::session::ValuePlan* value_plan);

  // .session.TableGetPlan table_get_pan = 9;
  bool has_table_get_pan() const;
  void clear_table_get_pan();
  static const int kTableGetPanFieldNumber = 9;
  private:
  const ::session::TableGetPlan& _internal_table_get_pan() const;
  public:
  const ::session::TableGetPlan& table_get_pan() const;
  ::session::TableGetPlan* release_table_get_pan();
  ::session::TableGetPlan* mutable_table_get_pan();
  void set_allocated_table_get_pan(::session::TableGetPlan* table_get_pan);

  // .session.DistributedPlan distributed_plan = 10;
  bool has_distributed_plan() const;
  void clear_distributed_plan();
  static const int kDistributedPlanFieldNumber = 10;
  private:
  const ::session::DistributedPlan& _internal_distributed_plan() const;
  public:
  const ::session::DistributedPlan& distributed_plan() const;
  ::session::DistributedPlan* release_distributed_plan();
  ::session::DistributedPlan* mutable_distributed_plan();
  void set_allocated_distributed_plan(::session::DistributedPlan* distributed_plan);

  void clear_child_plan();
  ChildPlanCase child_plan_case() const;
  // @@protoc_insertion_point(class_scope:session.ChildPlan)
 private:
  void set_has_seq_scan_plan();
  void set_has_filter_plan();
  void set_has_project_plan();
  void set_has_insert_plan();
  void set_has_delete_plan();
  void set_has_update_plan();
  void set_has_nestedloop_join_plan();
  void set_has_value_plan();
  void set_has_table_get_pan();
  void set_has_distributed_plan();

  inline bool has_child_plan() const;
  inline void clear_has_child_plan();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ChildPlanUnion {
    ChildPlanUnion() {}
    ::session::SeqScanPlan* seq_scan_plan_;
    ::session::FilterPlan* filter_plan_;
    ::session::ProjectionPlan* project_plan_;
    ::session::InsertPlan* insert_plan_;
    ::session::DeletePlan* delete_plan_;
    ::session::UpdatePlan* update_plan_;
    ::session::NestedLoopJoin* nestedloop_join_plan_;
    ::session::ValuePlan* value_plan_;
    ::session::TableGetPlan* table_get_pan_;
    ::session::DistributedPlan* distributed_plan_;
  } child_plan_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_session_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ValuePlan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:session.ValuePlan) */ {
 public:
  ValuePlan();
  virtual ~ValuePlan();

  ValuePlan(const ValuePlan& from);

  inline ValuePlan& operator=(const ValuePlan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ValuePlan(ValuePlan&& from) noexcept
    : ValuePlan() {
    *this = ::std::move(from);
  }

  inline ValuePlan& operator=(ValuePlan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ValuePlan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValuePlan* internal_default_instance() {
    return reinterpret_cast<const ValuePlan*>(
               &_ValuePlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ValuePlan* other);
  friend void swap(ValuePlan& a, ValuePlan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ValuePlan* New() const final {
    return CreateMaybeMessage<ValuePlan>(NULL);
  }

  ValuePlan* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ValuePlan>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ValuePlan& from);
  void MergeFrom(const ValuePlan& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValuePlan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string value = 2;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value(int index) const;
  ::std::string* mutable_value(int index);
  void set_value(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_value(int index, ::std::string&& value);
  #endif
  void set_value(int index, const char* value);
  void set_value(int index, const char* value, size_t size);
  ::std::string* add_value();
  void add_value(const ::std::string& value);
  #if LANG_CXX11
  void add_value(::std::string&& value);
  #endif
  void add_value(const char* value);
  void add_value(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& value() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value();

  // @@protoc_insertion_point(class_scope:session.ValuePlan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_session_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SeqScanPlan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:session.SeqScanPlan) */ {
 public:
  SeqScanPlan();
  virtual ~SeqScanPlan();

  SeqScanPlan(const SeqScanPlan& from);

  inline SeqScanPlan& operator=(const SeqScanPlan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SeqScanPlan(SeqScanPlan&& from) noexcept
    : SeqScanPlan() {
    *this = ::std::move(from);
  }

  inline SeqScanPlan& operator=(SeqScanPlan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SeqScanPlan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SeqScanPlan* internal_default_instance() {
    return reinterpret_cast<const SeqScanPlan*>(
               &_SeqScanPlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(SeqScanPlan* other);
  friend void swap(SeqScanPlan& a, SeqScanPlan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SeqScanPlan* New() const final {
    return CreateMaybeMessage<SeqScanPlan>(NULL);
  }

  SeqScanPlan* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SeqScanPlan>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SeqScanPlan& from);
  void MergeFrom(const SeqScanPlan& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SeqScanPlan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .session.ChildPlan child = 4;
  int child_size() const;
  void clear_child();
  static const int kChildFieldNumber = 4;
  ::session::ChildPlan* mutable_child(int index);
  ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >*
      mutable_child();
  const ::session::ChildPlan& child(int index) const;
  ::session::ChildPlan* add_child();
  const ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >&
      child() const;

  // string db_name = 1;
  void clear_db_name();
  static const int kDbNameFieldNumber = 1;
  const ::std::string& db_name() const;
  void set_db_name(const ::std::string& value);
  #if LANG_CXX11
  void set_db_name(::std::string&& value);
  #endif
  void set_db_name(const char* value);
  void set_db_name(const char* value, size_t size);
  ::std::string* mutable_db_name();
  ::std::string* release_db_name();
  void set_allocated_db_name(::std::string* db_name);

  // string tab_name = 2;
  void clear_tab_name();
  static const int kTabNameFieldNumber = 2;
  const ::std::string& tab_name() const;
  void set_tab_name(const ::std::string& value);
  #if LANG_CXX11
  void set_tab_name(::std::string&& value);
  #endif
  void set_tab_name(const char* value);
  void set_tab_name(const char* value, size_t size);
  ::std::string* mutable_tab_name();
  ::std::string* release_tab_name();
  void set_allocated_tab_name(::std::string* tab_name);

  // sint32 par_id = 3;
  void clear_par_id();
  static const int kParIdFieldNumber = 3;
  ::google::protobuf::int32 par_id() const;
  void set_par_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:session.SeqScanPlan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::session::ChildPlan > child_;
  ::google::protobuf::internal::ArenaStringPtr db_name_;
  ::google::protobuf::internal::ArenaStringPtr tab_name_;
  ::google::protobuf::int32 par_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_session_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TableGetPlan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:session.TableGetPlan) */ {
 public:
  TableGetPlan();
  virtual ~TableGetPlan();

  TableGetPlan(const TableGetPlan& from);

  inline TableGetPlan& operator=(const TableGetPlan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TableGetPlan(TableGetPlan&& from) noexcept
    : TableGetPlan() {
    *this = ::std::move(from);
  }

  inline TableGetPlan& operator=(TableGetPlan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TableGetPlan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TableGetPlan* internal_default_instance() {
    return reinterpret_cast<const TableGetPlan*>(
               &_TableGetPlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(TableGetPlan* other);
  friend void swap(TableGetPlan& a, TableGetPlan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TableGetPlan* New() const final {
    return CreateMaybeMessage<TableGetPlan>(NULL);
  }

  TableGetPlan* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TableGetPlan>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TableGetPlan& from);
  void MergeFrom(const TableGetPlan& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableGetPlan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .session.ChildPlan child = 5;
  int child_size() const;
  void clear_child();
  static const int kChildFieldNumber = 5;
  ::session::ChildPlan* mutable_child(int index);
  ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >*
      mutable_child();
  const ::session::ChildPlan& child(int index) const;
  ::session::ChildPlan* add_child();
  const ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >&
      child() const;

  // string db_name = 1;
  void clear_db_name();
  static const int kDbNameFieldNumber = 1;
  const ::std::string& db_name() const;
  void set_db_name(const ::std::string& value);
  #if LANG_CXX11
  void set_db_name(::std::string&& value);
  #endif
  void set_db_name(const char* value);
  void set_db_name(const char* value, size_t size);
  ::std::string* mutable_db_name();
  ::std::string* release_db_name();
  void set_allocated_db_name(::std::string* db_name);

  // string tab_name = 2;
  void clear_tab_name();
  static const int kTabNameFieldNumber = 2;
  const ::std::string& tab_name() const;
  void set_tab_name(const ::std::string& value);
  #if LANG_CXX11
  void set_tab_name(::std::string&& value);
  #endif
  void set_tab_name(const char* value);
  void set_tab_name(const char* value, size_t size);
  ::std::string* mutable_tab_name();
  ::std::string* release_tab_name();
  void set_allocated_tab_name(::std::string* tab_name);

  // string key = 4;
  void clear_key();
  static const int kKeyFieldNumber = 4;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // sint32 par_id = 3;
  void clear_par_id();
  static const int kParIdFieldNumber = 3;
  ::google::protobuf::int32 par_id() const;
  void set_par_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:session.TableGetPlan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::session::ChildPlan > child_;
  ::google::protobuf::internal::ArenaStringPtr db_name_;
  ::google::protobuf::internal::ArenaStringPtr tab_name_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::int32 par_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_session_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FilterPlan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:session.FilterPlan) */ {
 public:
  FilterPlan();
  virtual ~FilterPlan();

  FilterPlan(const FilterPlan& from);

  inline FilterPlan& operator=(const FilterPlan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FilterPlan(FilterPlan&& from) noexcept
    : FilterPlan() {
    *this = ::std::move(from);
  }

  inline FilterPlan& operator=(FilterPlan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterPlan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FilterPlan* internal_default_instance() {
    return reinterpret_cast<const FilterPlan*>(
               &_FilterPlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(FilterPlan* other);
  friend void swap(FilterPlan& a, FilterPlan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FilterPlan* New() const final {
    return CreateMaybeMessage<FilterPlan>(NULL);
  }

  FilterPlan* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FilterPlan>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FilterPlan& from);
  void MergeFrom(const FilterPlan& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilterPlan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .session.Expression expression = 1;
  int expression_size() const;
  void clear_expression();
  static const int kExpressionFieldNumber = 1;
  ::session::Expression* mutable_expression(int index);
  ::google::protobuf::RepeatedPtrField< ::session::Expression >*
      mutable_expression();
  const ::session::Expression& expression(int index) const;
  ::session::Expression* add_expression();
  const ::google::protobuf::RepeatedPtrField< ::session::Expression >&
      expression() const;

  // repeated .session.ChildPlan child = 2;
  int child_size() const;
  void clear_child();
  static const int kChildFieldNumber = 2;
  ::session::ChildPlan* mutable_child(int index);
  ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >*
      mutable_child();
  const ::session::ChildPlan& child(int index) const;
  ::session::ChildPlan* add_child();
  const ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >&
      child() const;

  // @@protoc_insertion_point(class_scope:session.FilterPlan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::session::Expression > expression_;
  ::google::protobuf::RepeatedPtrField< ::session::ChildPlan > child_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_session_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InsertPlan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:session.InsertPlan) */ {
 public:
  InsertPlan();
  virtual ~InsertPlan();

  InsertPlan(const InsertPlan& from);

  inline InsertPlan& operator=(const InsertPlan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InsertPlan(InsertPlan&& from) noexcept
    : InsertPlan() {
    *this = ::std::move(from);
  }

  inline InsertPlan& operator=(InsertPlan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InsertPlan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InsertPlan* internal_default_instance() {
    return reinterpret_cast<const InsertPlan*>(
               &_InsertPlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(InsertPlan* other);
  friend void swap(InsertPlan& a, InsertPlan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InsertPlan* New() const final {
    return CreateMaybeMessage<InsertPlan>(NULL);
  }

  InsertPlan* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InsertPlan>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InsertPlan& from);
  void MergeFrom(const InsertPlan& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertPlan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .session.ChildPlan child = 4;
  int child_size() const;
  void clear_child();
  static const int kChildFieldNumber = 4;
  ::session::ChildPlan* mutable_child(int index);
  ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >*
      mutable_child();
  const ::session::ChildPlan& child(int index) const;
  ::session::ChildPlan* add_child();
  const ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >&
      child() const;

  // string db_name = 1;
  void clear_db_name();
  static const int kDbNameFieldNumber = 1;
  const ::std::string& db_name() const;
  void set_db_name(const ::std::string& value);
  #if LANG_CXX11
  void set_db_name(::std::string&& value);
  #endif
  void set_db_name(const char* value);
  void set_db_name(const char* value, size_t size);
  ::std::string* mutable_db_name();
  ::std::string* release_db_name();
  void set_allocated_db_name(::std::string* db_name);

  // string tab_name = 2;
  void clear_tab_name();
  static const int kTabNameFieldNumber = 2;
  const ::std::string& tab_name() const;
  void set_tab_name(const ::std::string& value);
  #if LANG_CXX11
  void set_tab_name(::std::string&& value);
  #endif
  void set_tab_name(const char* value);
  void set_tab_name(const char* value, size_t size);
  ::std::string* mutable_tab_name();
  ::std::string* release_tab_name();
  void set_allocated_tab_name(::std::string* tab_name);

  // sint32 par_id = 3;
  void clear_par_id();
  static const int kParIdFieldNumber = 3;
  ::google::protobuf::int32 par_id() const;
  void set_par_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:session.InsertPlan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::session::ChildPlan > child_;
  ::google::protobuf::internal::ArenaStringPtr db_name_;
  ::google::protobuf::internal::ArenaStringPtr tab_name_;
  ::google::protobuf::int32 par_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_session_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeletePlan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:session.DeletePlan) */ {
 public:
  DeletePlan();
  virtual ~DeletePlan();

  DeletePlan(const DeletePlan& from);

  inline DeletePlan& operator=(const DeletePlan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeletePlan(DeletePlan&& from) noexcept
    : DeletePlan() {
    *this = ::std::move(from);
  }

  inline DeletePlan& operator=(DeletePlan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeletePlan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeletePlan* internal_default_instance() {
    return reinterpret_cast<const DeletePlan*>(
               &_DeletePlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(DeletePlan* other);
  friend void swap(DeletePlan& a, DeletePlan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeletePlan* New() const final {
    return CreateMaybeMessage<DeletePlan>(NULL);
  }

  DeletePlan* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeletePlan>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeletePlan& from);
  void MergeFrom(const DeletePlan& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeletePlan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .session.ChildPlan child = 4;
  int child_size() const;
  void clear_child();
  static const int kChildFieldNumber = 4;
  ::session::ChildPlan* mutable_child(int index);
  ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >*
      mutable_child();
  const ::session::ChildPlan& child(int index) const;
  ::session::ChildPlan* add_child();
  const ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >&
      child() const;

  // string db_name = 1;
  void clear_db_name();
  static const int kDbNameFieldNumber = 1;
  const ::std::string& db_name() const;
  void set_db_name(const ::std::string& value);
  #if LANG_CXX11
  void set_db_name(::std::string&& value);
  #endif
  void set_db_name(const char* value);
  void set_db_name(const char* value, size_t size);
  ::std::string* mutable_db_name();
  ::std::string* release_db_name();
  void set_allocated_db_name(::std::string* db_name);

  // string tab_name = 2;
  void clear_tab_name();
  static const int kTabNameFieldNumber = 2;
  const ::std::string& tab_name() const;
  void set_tab_name(const ::std::string& value);
  #if LANG_CXX11
  void set_tab_name(::std::string&& value);
  #endif
  void set_tab_name(const char* value);
  void set_tab_name(const char* value, size_t size);
  ::std::string* mutable_tab_name();
  ::std::string* release_tab_name();
  void set_allocated_tab_name(::std::string* tab_name);

  // sint32 par_id = 3;
  void clear_par_id();
  static const int kParIdFieldNumber = 3;
  ::google::protobuf::int32 par_id() const;
  void set_par_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:session.DeletePlan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::session::ChildPlan > child_;
  ::google::protobuf::internal::ArenaStringPtr db_name_;
  ::google::protobuf::internal::ArenaStringPtr tab_name_;
  ::google::protobuf::int32 par_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_session_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdatePlan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:session.UpdatePlan) */ {
 public:
  UpdatePlan();
  virtual ~UpdatePlan();

  UpdatePlan(const UpdatePlan& from);

  inline UpdatePlan& operator=(const UpdatePlan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdatePlan(UpdatePlan&& from) noexcept
    : UpdatePlan() {
    *this = ::std::move(from);
  }

  inline UpdatePlan& operator=(UpdatePlan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdatePlan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdatePlan* internal_default_instance() {
    return reinterpret_cast<const UpdatePlan*>(
               &_UpdatePlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(UpdatePlan* other);
  friend void swap(UpdatePlan& a, UpdatePlan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdatePlan* New() const final {
    return CreateMaybeMessage<UpdatePlan>(NULL);
  }

  UpdatePlan* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdatePlan>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdatePlan& from);
  void MergeFrom(const UpdatePlan& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePlan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .session.ChildPlan child = 4;
  int child_size() const;
  void clear_child();
  static const int kChildFieldNumber = 4;
  ::session::ChildPlan* mutable_child(int index);
  ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >*
      mutable_child();
  const ::session::ChildPlan& child(int index) const;
  ::session::ChildPlan* add_child();
  const ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >&
      child() const;

  // string db_name = 1;
  void clear_db_name();
  static const int kDbNameFieldNumber = 1;
  const ::std::string& db_name() const;
  void set_db_name(const ::std::string& value);
  #if LANG_CXX11
  void set_db_name(::std::string&& value);
  #endif
  void set_db_name(const char* value);
  void set_db_name(const char* value, size_t size);
  ::std::string* mutable_db_name();
  ::std::string* release_db_name();
  void set_allocated_db_name(::std::string* db_name);

  // string tab_name = 2;
  void clear_tab_name();
  static const int kTabNameFieldNumber = 2;
  const ::std::string& tab_name() const;
  void set_tab_name(const ::std::string& value);
  #if LANG_CXX11
  void set_tab_name(::std::string&& value);
  #endif
  void set_tab_name(const char* value);
  void set_tab_name(const char* value, size_t size);
  ::std::string* mutable_tab_name();
  ::std::string* release_tab_name();
  void set_allocated_tab_name(::std::string* tab_name);

  // sint32 par_id = 3;
  void clear_par_id();
  static const int kParIdFieldNumber = 3;
  ::google::protobuf::int32 par_id() const;
  void set_par_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:session.UpdatePlan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::session::ChildPlan > child_;
  ::google::protobuf::internal::ArenaStringPtr db_name_;
  ::google::protobuf::internal::ArenaStringPtr tab_name_;
  ::google::protobuf::int32 par_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_session_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProjectionPlan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:session.ProjectionPlan) */ {
 public:
  ProjectionPlan();
  virtual ~ProjectionPlan();

  ProjectionPlan(const ProjectionPlan& from);

  inline ProjectionPlan& operator=(const ProjectionPlan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProjectionPlan(ProjectionPlan&& from) noexcept
    : ProjectionPlan() {
    *this = ::std::move(from);
  }

  inline ProjectionPlan& operator=(ProjectionPlan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProjectionPlan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProjectionPlan* internal_default_instance() {
    return reinterpret_cast<const ProjectionPlan*>(
               &_ProjectionPlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ProjectionPlan* other);
  friend void swap(ProjectionPlan& a, ProjectionPlan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProjectionPlan* New() const final {
    return CreateMaybeMessage<ProjectionPlan>(NULL);
  }

  ProjectionPlan* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProjectionPlan>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProjectionPlan& from);
  void MergeFrom(const ProjectionPlan& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProjectionPlan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string col_name = 2;
  int col_name_size() const;
  void clear_col_name();
  static const int kColNameFieldNumber = 2;
  const ::std::string& col_name(int index) const;
  ::std::string* mutable_col_name(int index);
  void set_col_name(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_col_name(int index, ::std::string&& value);
  #endif
  void set_col_name(int index, const char* value);
  void set_col_name(int index, const char* value, size_t size);
  ::std::string* add_col_name();
  void add_col_name(const ::std::string& value);
  #if LANG_CXX11
  void add_col_name(::std::string&& value);
  #endif
  void add_col_name(const char* value);
  void add_col_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& col_name() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_col_name();

  // repeated .session.ChildPlan child = 3;
  int child_size() const;
  void clear_child();
  static const int kChildFieldNumber = 3;
  ::session::ChildPlan* mutable_child(int index);
  ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >*
      mutable_child();
  const ::session::ChildPlan& child(int index) const;
  ::session::ChildPlan* add_child();
  const ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >&
      child() const;

  // string tab_name = 1;
  void clear_tab_name();
  static const int kTabNameFieldNumber = 1;
  const ::std::string& tab_name() const;
  void set_tab_name(const ::std::string& value);
  #if LANG_CXX11
  void set_tab_name(::std::string&& value);
  #endif
  void set_tab_name(const char* value);
  void set_tab_name(const char* value, size_t size);
  ::std::string* mutable_tab_name();
  ::std::string* release_tab_name();
  void set_allocated_tab_name(::std::string* tab_name);

  // @@protoc_insertion_point(class_scope:session.ProjectionPlan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> col_name_;
  ::google::protobuf::RepeatedPtrField< ::session::ChildPlan > child_;
  ::google::protobuf::internal::ArenaStringPtr tab_name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_session_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NestedLoopJoin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:session.NestedLoopJoin) */ {
 public:
  NestedLoopJoin();
  virtual ~NestedLoopJoin();

  NestedLoopJoin(const NestedLoopJoin& from);

  inline NestedLoopJoin& operator=(const NestedLoopJoin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NestedLoopJoin(NestedLoopJoin&& from) noexcept
    : NestedLoopJoin() {
    *this = ::std::move(from);
  }

  inline NestedLoopJoin& operator=(NestedLoopJoin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NestedLoopJoin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NestedLoopJoin* internal_default_instance() {
    return reinterpret_cast<const NestedLoopJoin*>(
               &_NestedLoopJoin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(NestedLoopJoin* other);
  friend void swap(NestedLoopJoin& a, NestedLoopJoin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NestedLoopJoin* New() const final {
    return CreateMaybeMessage<NestedLoopJoin>(NULL);
  }

  NestedLoopJoin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NestedLoopJoin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NestedLoopJoin& from);
  void MergeFrom(const NestedLoopJoin& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NestedLoopJoin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .session.ChildPlan child = 2;
  int child_size() const;
  void clear_child();
  static const int kChildFieldNumber = 2;
  ::session::ChildPlan* mutable_child(int index);
  ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >*
      mutable_child();
  const ::session::ChildPlan& child(int index) const;
  ::session::ChildPlan* add_child();
  const ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >&
      child() const;

  // .session.JoinType jointype = 1;
  void clear_jointype();
  static const int kJointypeFieldNumber = 1;
  ::session::JoinType jointype() const;
  void set_jointype(::session::JoinType value);

  // @@protoc_insertion_point(class_scope:session.NestedLoopJoin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::session::ChildPlan > child_;
  int jointype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_session_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DistributedPlan_Node : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:session.DistributedPlan.Node) */ {
 public:
  DistributedPlan_Node();
  virtual ~DistributedPlan_Node();

  DistributedPlan_Node(const DistributedPlan_Node& from);

  inline DistributedPlan_Node& operator=(const DistributedPlan_Node& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DistributedPlan_Node(DistributedPlan_Node&& from) noexcept
    : DistributedPlan_Node() {
    *this = ::std::move(from);
  }

  inline DistributedPlan_Node& operator=(DistributedPlan_Node&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DistributedPlan_Node& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DistributedPlan_Node* internal_default_instance() {
    return reinterpret_cast<const DistributedPlan_Node*>(
               &_DistributedPlan_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(DistributedPlan_Node* other);
  friend void swap(DistributedPlan_Node& a, DistributedPlan_Node& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DistributedPlan_Node* New() const final {
    return CreateMaybeMessage<DistributedPlan_Node>(NULL);
  }

  DistributedPlan_Node* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DistributedPlan_Node>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DistributedPlan_Node& from);
  void MergeFrom(const DistributedPlan_Node& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DistributedPlan_Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ip_addr = 1;
  void clear_ip_addr();
  static const int kIpAddrFieldNumber = 1;
  const ::std::string& ip_addr() const;
  void set_ip_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_ip_addr(::std::string&& value);
  #endif
  void set_ip_addr(const char* value);
  void set_ip_addr(const char* value, size_t size);
  ::std::string* mutable_ip_addr();
  ::std::string* release_ip_addr();
  void set_allocated_ip_addr(::std::string* ip_addr);

  // sint32 port = 2;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:session.DistributedPlan.Node)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ip_addr_;
  ::google::protobuf::int32 port_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_session_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DistributedPlan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:session.DistributedPlan) */ {
 public:
  DistributedPlan();
  virtual ~DistributedPlan();

  DistributedPlan(const DistributedPlan& from);

  inline DistributedPlan& operator=(const DistributedPlan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DistributedPlan(DistributedPlan&& from) noexcept
    : DistributedPlan() {
    *this = ::std::move(from);
  }

  inline DistributedPlan& operator=(DistributedPlan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DistributedPlan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DistributedPlan* internal_default_instance() {
    return reinterpret_cast<const DistributedPlan*>(
               &_DistributedPlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(DistributedPlan* other);
  friend void swap(DistributedPlan& a, DistributedPlan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DistributedPlan* New() const final {
    return CreateMaybeMessage<DistributedPlan>(NULL);
  }

  DistributedPlan* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DistributedPlan>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DistributedPlan& from);
  void MergeFrom(const DistributedPlan& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DistributedPlan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DistributedPlan_Node Node;

  // accessors -------------------------------------------------------

  // repeated .session.DistributedPlan.Node nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  ::session::DistributedPlan_Node* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::session::DistributedPlan_Node >*
      mutable_nodes();
  const ::session::DistributedPlan_Node& nodes(int index) const;
  ::session::DistributedPlan_Node* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::session::DistributedPlan_Node >&
      nodes() const;

  // repeated .session.ChildPlan plans = 2;
  int plans_size() const;
  void clear_plans();
  static const int kPlansFieldNumber = 2;
  ::session::ChildPlan* mutable_plans(int index);
  ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >*
      mutable_plans();
  const ::session::ChildPlan& plans(int index) const;
  ::session::ChildPlan* add_plans();
  const ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >&
      plans() const;

  // @@protoc_insertion_point(class_scope:session.DistributedPlan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::session::DistributedPlan_Node > nodes_;
  ::google::protobuf::RepeatedPtrField< ::session::ChildPlan > plans_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_session_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RemotePlan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:session.RemotePlan) */ {
 public:
  RemotePlan();
  virtual ~RemotePlan();

  RemotePlan(const RemotePlan& from);

  inline RemotePlan& operator=(const RemotePlan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemotePlan(RemotePlan&& from) noexcept
    : RemotePlan() {
    *this = ::std::move(from);
  }

  inline RemotePlan& operator=(RemotePlan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemotePlan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemotePlan* internal_default_instance() {
    return reinterpret_cast<const RemotePlan*>(
               &_RemotePlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(RemotePlan* other);
  friend void swap(RemotePlan& a, RemotePlan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemotePlan* New() const final {
    return CreateMaybeMessage<RemotePlan>(NULL);
  }

  RemotePlan* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RemotePlan>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RemotePlan& from);
  void MergeFrom(const RemotePlan& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemotePlan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .session.ChildPlan child = 1;
  bool has_child() const;
  void clear_child();
  static const int kChildFieldNumber = 1;
  private:
  const ::session::ChildPlan& _internal_child() const;
  public:
  const ::session::ChildPlan& child() const;
  ::session::ChildPlan* release_child();
  ::session::ChildPlan* mutable_child();
  void set_allocated_child(::session::ChildPlan* child);

  // @@protoc_insertion_point(class_scope:session.RemotePlan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::session::ChildPlan* child_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_session_2eproto::TableStruct;
};
// ===================================================================

class Session_Service_Stub;

class Session_Service : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline Session_Service() {};
 public:
  virtual ~Session_Service();

  typedef Session_Service_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void SQL_Transfer(::google::protobuf::RpcController* controller,
                       const ::session::SQL_Request* request,
                       ::session::SQL_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void SendRemotePlan(::google::protobuf::RpcController* controller,
                       const ::session::RemotePlan* request,
                       ::session::Table* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(Session_Service);
};

class Session_Service_Stub : public Session_Service {
 public:
  Session_Service_Stub(::google::protobuf::RpcChannel* channel);
  Session_Service_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~Session_Service_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements Session_Service ------------------------------------------

  void SQL_Transfer(::google::protobuf::RpcController* controller,
                       const ::session::SQL_Request* request,
                       ::session::SQL_Response* response,
                       ::google::protobuf::Closure* done);
  void SendRemotePlan(::google::protobuf::RpcController* controller,
                       const ::session::RemotePlan* request,
                       ::session::Table* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(Session_Service_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Value

// sint32 value = 1;
inline void Value::clear_value() {
  value_ = 0;
}
inline ::google::protobuf::int32 Value::value() const {
  // @@protoc_insertion_point(field_get:session.Value.value)
  return value_;
}
inline void Value::set_value(::google::protobuf::int32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:session.Value.value)
}

// -------------------------------------------------------------------

// Tuple

// repeated .session.Value tuple = 1;
inline int Tuple::tuple_size() const {
  return tuple_.size();
}
inline void Tuple::clear_tuple() {
  tuple_.Clear();
}
inline ::session::Value* Tuple::mutable_tuple(int index) {
  // @@protoc_insertion_point(field_mutable:session.Tuple.tuple)
  return tuple_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::session::Value >*
Tuple::mutable_tuple() {
  // @@protoc_insertion_point(field_mutable_list:session.Tuple.tuple)
  return &tuple_;
}
inline const ::session::Value& Tuple::tuple(int index) const {
  // @@protoc_insertion_point(field_get:session.Tuple.tuple)
  return tuple_.Get(index);
}
inline ::session::Value* Tuple::add_tuple() {
  // @@protoc_insertion_point(field_add:session.Tuple.tuple)
  return tuple_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::session::Value >&
Tuple::tuple() const {
  // @@protoc_insertion_point(field_list:session.Tuple.tuple)
  return tuple_;
}

// -------------------------------------------------------------------

// Table

// repeated .session.Tuple table = 1;
inline int Table::table_size() const {
  return table_.size();
}
inline void Table::clear_table() {
  table_.Clear();
}
inline ::session::Tuple* Table::mutable_table(int index) {
  // @@protoc_insertion_point(field_mutable:session.Table.table)
  return table_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::session::Tuple >*
Table::mutable_table() {
  // @@protoc_insertion_point(field_mutable_list:session.Table.table)
  return &table_;
}
inline const ::session::Tuple& Table::table(int index) const {
  // @@protoc_insertion_point(field_get:session.Table.table)
  return table_.Get(index);
}
inline ::session::Tuple* Table::add_table() {
  // @@protoc_insertion_point(field_add:session.Table.table)
  return table_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::session::Tuple >&
Table::table() const {
  // @@protoc_insertion_point(field_list:session.Table.table)
  return table_;
}

// -------------------------------------------------------------------

// SQL_Request

// string Sql_statement = 1;
inline void SQL_Request::clear_sql_statement() {
  sql_statement_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SQL_Request::sql_statement() const {
  // @@protoc_insertion_point(field_get:session.SQL_Request.Sql_statement)
  return sql_statement_.GetNoArena();
}
inline void SQL_Request::set_sql_statement(const ::std::string& value) {
  
  sql_statement_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:session.SQL_Request.Sql_statement)
}
#if LANG_CXX11
inline void SQL_Request::set_sql_statement(::std::string&& value) {
  
  sql_statement_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:session.SQL_Request.Sql_statement)
}
#endif
inline void SQL_Request::set_sql_statement(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sql_statement_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:session.SQL_Request.Sql_statement)
}
inline void SQL_Request::set_sql_statement(const char* value, size_t size) {
  
  sql_statement_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:session.SQL_Request.Sql_statement)
}
inline ::std::string* SQL_Request::mutable_sql_statement() {
  
  // @@protoc_insertion_point(field_mutable:session.SQL_Request.Sql_statement)
  return sql_statement_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SQL_Request::release_sql_statement() {
  // @@protoc_insertion_point(field_release:session.SQL_Request.Sql_statement)
  
  return sql_statement_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SQL_Request::set_allocated_sql_statement(::std::string* sql_statement) {
  if (sql_statement != NULL) {
    
  } else {
    
  }
  sql_statement_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sql_statement);
  // @@protoc_insertion_point(field_set_allocated:session.SQL_Request.Sql_statement)
}

// -------------------------------------------------------------------

// SQL_Response

// .session.Table Sql_response = 1;
inline bool SQL_Response::has_sql_response() const {
  return this != internal_default_instance() && sql_response_ != NULL;
}
inline void SQL_Response::clear_sql_response() {
  if (GetArenaNoVirtual() == NULL && sql_response_ != NULL) {
    delete sql_response_;
  }
  sql_response_ = NULL;
}
inline const ::session::Table& SQL_Response::_internal_sql_response() const {
  return *sql_response_;
}
inline const ::session::Table& SQL_Response::sql_response() const {
  const ::session::Table* p = sql_response_;
  // @@protoc_insertion_point(field_get:session.SQL_Response.Sql_response)
  return p != NULL ? *p : *reinterpret_cast<const ::session::Table*>(
      &::session::_Table_default_instance_);
}
inline ::session::Table* SQL_Response::release_sql_response() {
  // @@protoc_insertion_point(field_release:session.SQL_Response.Sql_response)
  
  ::session::Table* temp = sql_response_;
  sql_response_ = NULL;
  return temp;
}
inline ::session::Table* SQL_Response::mutable_sql_response() {
  
  if (sql_response_ == NULL) {
    auto* p = CreateMaybeMessage<::session::Table>(GetArenaNoVirtual());
    sql_response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:session.SQL_Response.Sql_response)
  return sql_response_;
}
inline void SQL_Response::set_allocated_sql_response(::session::Table* sql_response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sql_response_;
  }
  if (sql_response) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sql_response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sql_response, submessage_arena);
    }
    
  } else {
    
  }
  sql_response_ = sql_response;
  // @@protoc_insertion_point(field_set_allocated:session.SQL_Response.Sql_response)
}

// -------------------------------------------------------------------

// Expression

// string str_expression = 1;
inline void Expression::clear_str_expression() {
  str_expression_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Expression::str_expression() const {
  // @@protoc_insertion_point(field_get:session.Expression.str_expression)
  return str_expression_.GetNoArena();
}
inline void Expression::set_str_expression(const ::std::string& value) {
  
  str_expression_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:session.Expression.str_expression)
}
#if LANG_CXX11
inline void Expression::set_str_expression(::std::string&& value) {
  
  str_expression_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:session.Expression.str_expression)
}
#endif
inline void Expression::set_str_expression(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  str_expression_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:session.Expression.str_expression)
}
inline void Expression::set_str_expression(const char* value, size_t size) {
  
  str_expression_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:session.Expression.str_expression)
}
inline ::std::string* Expression::mutable_str_expression() {
  
  // @@protoc_insertion_point(field_mutable:session.Expression.str_expression)
  return str_expression_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Expression::release_str_expression() {
  // @@protoc_insertion_point(field_release:session.Expression.str_expression)
  
  return str_expression_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Expression::set_allocated_str_expression(::std::string* str_expression) {
  if (str_expression != NULL) {
    
  } else {
    
  }
  str_expression_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), str_expression);
  // @@protoc_insertion_point(field_set_allocated:session.Expression.str_expression)
}

// -------------------------------------------------------------------

// ChildPlan

// .session.SeqScanPlan seq_scan_plan = 1;
inline bool ChildPlan::has_seq_scan_plan() const {
  return child_plan_case() == kSeqScanPlan;
}
inline void ChildPlan::set_has_seq_scan_plan() {
  _oneof_case_[0] = kSeqScanPlan;
}
inline void ChildPlan::clear_seq_scan_plan() {
  if (has_seq_scan_plan()) {
    delete child_plan_.seq_scan_plan_;
    clear_has_child_plan();
  }
}
inline const ::session::SeqScanPlan& ChildPlan::_internal_seq_scan_plan() const {
  return *child_plan_.seq_scan_plan_;
}
inline ::session::SeqScanPlan* ChildPlan::release_seq_scan_plan() {
  // @@protoc_insertion_point(field_release:session.ChildPlan.seq_scan_plan)
  if (has_seq_scan_plan()) {
    clear_has_child_plan();
      ::session::SeqScanPlan* temp = child_plan_.seq_scan_plan_;
    child_plan_.seq_scan_plan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::session::SeqScanPlan& ChildPlan::seq_scan_plan() const {
  // @@protoc_insertion_point(field_get:session.ChildPlan.seq_scan_plan)
  return has_seq_scan_plan()
      ? *child_plan_.seq_scan_plan_
      : *reinterpret_cast< ::session::SeqScanPlan*>(&::session::_SeqScanPlan_default_instance_);
}
inline ::session::SeqScanPlan* ChildPlan::mutable_seq_scan_plan() {
  if (!has_seq_scan_plan()) {
    clear_child_plan();
    set_has_seq_scan_plan();
    child_plan_.seq_scan_plan_ = CreateMaybeMessage< ::session::SeqScanPlan >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:session.ChildPlan.seq_scan_plan)
  return child_plan_.seq_scan_plan_;
}

// .session.FilterPlan filter_plan = 2;
inline bool ChildPlan::has_filter_plan() const {
  return child_plan_case() == kFilterPlan;
}
inline void ChildPlan::set_has_filter_plan() {
  _oneof_case_[0] = kFilterPlan;
}
inline void ChildPlan::clear_filter_plan() {
  if (has_filter_plan()) {
    delete child_plan_.filter_plan_;
    clear_has_child_plan();
  }
}
inline const ::session::FilterPlan& ChildPlan::_internal_filter_plan() const {
  return *child_plan_.filter_plan_;
}
inline ::session::FilterPlan* ChildPlan::release_filter_plan() {
  // @@protoc_insertion_point(field_release:session.ChildPlan.filter_plan)
  if (has_filter_plan()) {
    clear_has_child_plan();
      ::session::FilterPlan* temp = child_plan_.filter_plan_;
    child_plan_.filter_plan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::session::FilterPlan& ChildPlan::filter_plan() const {
  // @@protoc_insertion_point(field_get:session.ChildPlan.filter_plan)
  return has_filter_plan()
      ? *child_plan_.filter_plan_
      : *reinterpret_cast< ::session::FilterPlan*>(&::session::_FilterPlan_default_instance_);
}
inline ::session::FilterPlan* ChildPlan::mutable_filter_plan() {
  if (!has_filter_plan()) {
    clear_child_plan();
    set_has_filter_plan();
    child_plan_.filter_plan_ = CreateMaybeMessage< ::session::FilterPlan >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:session.ChildPlan.filter_plan)
  return child_plan_.filter_plan_;
}

// .session.ProjectionPlan project_plan = 3;
inline bool ChildPlan::has_project_plan() const {
  return child_plan_case() == kProjectPlan;
}
inline void ChildPlan::set_has_project_plan() {
  _oneof_case_[0] = kProjectPlan;
}
inline void ChildPlan::clear_project_plan() {
  if (has_project_plan()) {
    delete child_plan_.project_plan_;
    clear_has_child_plan();
  }
}
inline const ::session::ProjectionPlan& ChildPlan::_internal_project_plan() const {
  return *child_plan_.project_plan_;
}
inline ::session::ProjectionPlan* ChildPlan::release_project_plan() {
  // @@protoc_insertion_point(field_release:session.ChildPlan.project_plan)
  if (has_project_plan()) {
    clear_has_child_plan();
      ::session::ProjectionPlan* temp = child_plan_.project_plan_;
    child_plan_.project_plan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::session::ProjectionPlan& ChildPlan::project_plan() const {
  // @@protoc_insertion_point(field_get:session.ChildPlan.project_plan)
  return has_project_plan()
      ? *child_plan_.project_plan_
      : *reinterpret_cast< ::session::ProjectionPlan*>(&::session::_ProjectionPlan_default_instance_);
}
inline ::session::ProjectionPlan* ChildPlan::mutable_project_plan() {
  if (!has_project_plan()) {
    clear_child_plan();
    set_has_project_plan();
    child_plan_.project_plan_ = CreateMaybeMessage< ::session::ProjectionPlan >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:session.ChildPlan.project_plan)
  return child_plan_.project_plan_;
}

// .session.InsertPlan insert_plan = 4;
inline bool ChildPlan::has_insert_plan() const {
  return child_plan_case() == kInsertPlan;
}
inline void ChildPlan::set_has_insert_plan() {
  _oneof_case_[0] = kInsertPlan;
}
inline void ChildPlan::clear_insert_plan() {
  if (has_insert_plan()) {
    delete child_plan_.insert_plan_;
    clear_has_child_plan();
  }
}
inline const ::session::InsertPlan& ChildPlan::_internal_insert_plan() const {
  return *child_plan_.insert_plan_;
}
inline ::session::InsertPlan* ChildPlan::release_insert_plan() {
  // @@protoc_insertion_point(field_release:session.ChildPlan.insert_plan)
  if (has_insert_plan()) {
    clear_has_child_plan();
      ::session::InsertPlan* temp = child_plan_.insert_plan_;
    child_plan_.insert_plan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::session::InsertPlan& ChildPlan::insert_plan() const {
  // @@protoc_insertion_point(field_get:session.ChildPlan.insert_plan)
  return has_insert_plan()
      ? *child_plan_.insert_plan_
      : *reinterpret_cast< ::session::InsertPlan*>(&::session::_InsertPlan_default_instance_);
}
inline ::session::InsertPlan* ChildPlan::mutable_insert_plan() {
  if (!has_insert_plan()) {
    clear_child_plan();
    set_has_insert_plan();
    child_plan_.insert_plan_ = CreateMaybeMessage< ::session::InsertPlan >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:session.ChildPlan.insert_plan)
  return child_plan_.insert_plan_;
}

// .session.DeletePlan delete_plan = 5;
inline bool ChildPlan::has_delete_plan() const {
  return child_plan_case() == kDeletePlan;
}
inline void ChildPlan::set_has_delete_plan() {
  _oneof_case_[0] = kDeletePlan;
}
inline void ChildPlan::clear_delete_plan() {
  if (has_delete_plan()) {
    delete child_plan_.delete_plan_;
    clear_has_child_plan();
  }
}
inline const ::session::DeletePlan& ChildPlan::_internal_delete_plan() const {
  return *child_plan_.delete_plan_;
}
inline ::session::DeletePlan* ChildPlan::release_delete_plan() {
  // @@protoc_insertion_point(field_release:session.ChildPlan.delete_plan)
  if (has_delete_plan()) {
    clear_has_child_plan();
      ::session::DeletePlan* temp = child_plan_.delete_plan_;
    child_plan_.delete_plan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::session::DeletePlan& ChildPlan::delete_plan() const {
  // @@protoc_insertion_point(field_get:session.ChildPlan.delete_plan)
  return has_delete_plan()
      ? *child_plan_.delete_plan_
      : *reinterpret_cast< ::session::DeletePlan*>(&::session::_DeletePlan_default_instance_);
}
inline ::session::DeletePlan* ChildPlan::mutable_delete_plan() {
  if (!has_delete_plan()) {
    clear_child_plan();
    set_has_delete_plan();
    child_plan_.delete_plan_ = CreateMaybeMessage< ::session::DeletePlan >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:session.ChildPlan.delete_plan)
  return child_plan_.delete_plan_;
}

// .session.UpdatePlan update_plan = 6;
inline bool ChildPlan::has_update_plan() const {
  return child_plan_case() == kUpdatePlan;
}
inline void ChildPlan::set_has_update_plan() {
  _oneof_case_[0] = kUpdatePlan;
}
inline void ChildPlan::clear_update_plan() {
  if (has_update_plan()) {
    delete child_plan_.update_plan_;
    clear_has_child_plan();
  }
}
inline const ::session::UpdatePlan& ChildPlan::_internal_update_plan() const {
  return *child_plan_.update_plan_;
}
inline ::session::UpdatePlan* ChildPlan::release_update_plan() {
  // @@protoc_insertion_point(field_release:session.ChildPlan.update_plan)
  if (has_update_plan()) {
    clear_has_child_plan();
      ::session::UpdatePlan* temp = child_plan_.update_plan_;
    child_plan_.update_plan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::session::UpdatePlan& ChildPlan::update_plan() const {
  // @@protoc_insertion_point(field_get:session.ChildPlan.update_plan)
  return has_update_plan()
      ? *child_plan_.update_plan_
      : *reinterpret_cast< ::session::UpdatePlan*>(&::session::_UpdatePlan_default_instance_);
}
inline ::session::UpdatePlan* ChildPlan::mutable_update_plan() {
  if (!has_update_plan()) {
    clear_child_plan();
    set_has_update_plan();
    child_plan_.update_plan_ = CreateMaybeMessage< ::session::UpdatePlan >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:session.ChildPlan.update_plan)
  return child_plan_.update_plan_;
}

// .session.NestedLoopJoin nestedloop_join_plan = 7;
inline bool ChildPlan::has_nestedloop_join_plan() const {
  return child_plan_case() == kNestedloopJoinPlan;
}
inline void ChildPlan::set_has_nestedloop_join_plan() {
  _oneof_case_[0] = kNestedloopJoinPlan;
}
inline void ChildPlan::clear_nestedloop_join_plan() {
  if (has_nestedloop_join_plan()) {
    delete child_plan_.nestedloop_join_plan_;
    clear_has_child_plan();
  }
}
inline const ::session::NestedLoopJoin& ChildPlan::_internal_nestedloop_join_plan() const {
  return *child_plan_.nestedloop_join_plan_;
}
inline ::session::NestedLoopJoin* ChildPlan::release_nestedloop_join_plan() {
  // @@protoc_insertion_point(field_release:session.ChildPlan.nestedloop_join_plan)
  if (has_nestedloop_join_plan()) {
    clear_has_child_plan();
      ::session::NestedLoopJoin* temp = child_plan_.nestedloop_join_plan_;
    child_plan_.nestedloop_join_plan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::session::NestedLoopJoin& ChildPlan::nestedloop_join_plan() const {
  // @@protoc_insertion_point(field_get:session.ChildPlan.nestedloop_join_plan)
  return has_nestedloop_join_plan()
      ? *child_plan_.nestedloop_join_plan_
      : *reinterpret_cast< ::session::NestedLoopJoin*>(&::session::_NestedLoopJoin_default_instance_);
}
inline ::session::NestedLoopJoin* ChildPlan::mutable_nestedloop_join_plan() {
  if (!has_nestedloop_join_plan()) {
    clear_child_plan();
    set_has_nestedloop_join_plan();
    child_plan_.nestedloop_join_plan_ = CreateMaybeMessage< ::session::NestedLoopJoin >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:session.ChildPlan.nestedloop_join_plan)
  return child_plan_.nestedloop_join_plan_;
}

// .session.ValuePlan value_plan = 8;
inline bool ChildPlan::has_value_plan() const {
  return child_plan_case() == kValuePlan;
}
inline void ChildPlan::set_has_value_plan() {
  _oneof_case_[0] = kValuePlan;
}
inline void ChildPlan::clear_value_plan() {
  if (has_value_plan()) {
    delete child_plan_.value_plan_;
    clear_has_child_plan();
  }
}
inline const ::session::ValuePlan& ChildPlan::_internal_value_plan() const {
  return *child_plan_.value_plan_;
}
inline ::session::ValuePlan* ChildPlan::release_value_plan() {
  // @@protoc_insertion_point(field_release:session.ChildPlan.value_plan)
  if (has_value_plan()) {
    clear_has_child_plan();
      ::session::ValuePlan* temp = child_plan_.value_plan_;
    child_plan_.value_plan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::session::ValuePlan& ChildPlan::value_plan() const {
  // @@protoc_insertion_point(field_get:session.ChildPlan.value_plan)
  return has_value_plan()
      ? *child_plan_.value_plan_
      : *reinterpret_cast< ::session::ValuePlan*>(&::session::_ValuePlan_default_instance_);
}
inline ::session::ValuePlan* ChildPlan::mutable_value_plan() {
  if (!has_value_plan()) {
    clear_child_plan();
    set_has_value_plan();
    child_plan_.value_plan_ = CreateMaybeMessage< ::session::ValuePlan >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:session.ChildPlan.value_plan)
  return child_plan_.value_plan_;
}

// .session.TableGetPlan table_get_pan = 9;
inline bool ChildPlan::has_table_get_pan() const {
  return child_plan_case() == kTableGetPan;
}
inline void ChildPlan::set_has_table_get_pan() {
  _oneof_case_[0] = kTableGetPan;
}
inline void ChildPlan::clear_table_get_pan() {
  if (has_table_get_pan()) {
    delete child_plan_.table_get_pan_;
    clear_has_child_plan();
  }
}
inline const ::session::TableGetPlan& ChildPlan::_internal_table_get_pan() const {
  return *child_plan_.table_get_pan_;
}
inline ::session::TableGetPlan* ChildPlan::release_table_get_pan() {
  // @@protoc_insertion_point(field_release:session.ChildPlan.table_get_pan)
  if (has_table_get_pan()) {
    clear_has_child_plan();
      ::session::TableGetPlan* temp = child_plan_.table_get_pan_;
    child_plan_.table_get_pan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::session::TableGetPlan& ChildPlan::table_get_pan() const {
  // @@protoc_insertion_point(field_get:session.ChildPlan.table_get_pan)
  return has_table_get_pan()
      ? *child_plan_.table_get_pan_
      : *reinterpret_cast< ::session::TableGetPlan*>(&::session::_TableGetPlan_default_instance_);
}
inline ::session::TableGetPlan* ChildPlan::mutable_table_get_pan() {
  if (!has_table_get_pan()) {
    clear_child_plan();
    set_has_table_get_pan();
    child_plan_.table_get_pan_ = CreateMaybeMessage< ::session::TableGetPlan >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:session.ChildPlan.table_get_pan)
  return child_plan_.table_get_pan_;
}

// .session.DistributedPlan distributed_plan = 10;
inline bool ChildPlan::has_distributed_plan() const {
  return child_plan_case() == kDistributedPlan;
}
inline void ChildPlan::set_has_distributed_plan() {
  _oneof_case_[0] = kDistributedPlan;
}
inline void ChildPlan::clear_distributed_plan() {
  if (has_distributed_plan()) {
    delete child_plan_.distributed_plan_;
    clear_has_child_plan();
  }
}
inline const ::session::DistributedPlan& ChildPlan::_internal_distributed_plan() const {
  return *child_plan_.distributed_plan_;
}
inline ::session::DistributedPlan* ChildPlan::release_distributed_plan() {
  // @@protoc_insertion_point(field_release:session.ChildPlan.distributed_plan)
  if (has_distributed_plan()) {
    clear_has_child_plan();
      ::session::DistributedPlan* temp = child_plan_.distributed_plan_;
    child_plan_.distributed_plan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::session::DistributedPlan& ChildPlan::distributed_plan() const {
  // @@protoc_insertion_point(field_get:session.ChildPlan.distributed_plan)
  return has_distributed_plan()
      ? *child_plan_.distributed_plan_
      : *reinterpret_cast< ::session::DistributedPlan*>(&::session::_DistributedPlan_default_instance_);
}
inline ::session::DistributedPlan* ChildPlan::mutable_distributed_plan() {
  if (!has_distributed_plan()) {
    clear_child_plan();
    set_has_distributed_plan();
    child_plan_.distributed_plan_ = CreateMaybeMessage< ::session::DistributedPlan >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:session.ChildPlan.distributed_plan)
  return child_plan_.distributed_plan_;
}

inline bool ChildPlan::has_child_plan() const {
  return child_plan_case() != CHILD_PLAN_NOT_SET;
}
inline void ChildPlan::clear_has_child_plan() {
  _oneof_case_[0] = CHILD_PLAN_NOT_SET;
}
inline ChildPlan::ChildPlanCase ChildPlan::child_plan_case() const {
  return ChildPlan::ChildPlanCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ValuePlan

// repeated string value = 2;
inline int ValuePlan::value_size() const {
  return value_.size();
}
inline void ValuePlan::clear_value() {
  value_.Clear();
}
inline const ::std::string& ValuePlan::value(int index) const {
  // @@protoc_insertion_point(field_get:session.ValuePlan.value)
  return value_.Get(index);
}
inline ::std::string* ValuePlan::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:session.ValuePlan.value)
  return value_.Mutable(index);
}
inline void ValuePlan::set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:session.ValuePlan.value)
  value_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ValuePlan::set_value(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:session.ValuePlan.value)
  value_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ValuePlan::set_value(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:session.ValuePlan.value)
}
inline void ValuePlan::set_value(int index, const char* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:session.ValuePlan.value)
}
inline ::std::string* ValuePlan::add_value() {
  // @@protoc_insertion_point(field_add_mutable:session.ValuePlan.value)
  return value_.Add();
}
inline void ValuePlan::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:session.ValuePlan.value)
}
#if LANG_CXX11
inline void ValuePlan::add_value(::std::string&& value) {
  value_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:session.ValuePlan.value)
}
#endif
inline void ValuePlan::add_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:session.ValuePlan.value)
}
inline void ValuePlan::add_value(const char* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:session.ValuePlan.value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ValuePlan::value() const {
  // @@protoc_insertion_point(field_list:session.ValuePlan.value)
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ValuePlan::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:session.ValuePlan.value)
  return &value_;
}

// -------------------------------------------------------------------

// SeqScanPlan

// string db_name = 1;
inline void SeqScanPlan::clear_db_name() {
  db_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SeqScanPlan::db_name() const {
  // @@protoc_insertion_point(field_get:session.SeqScanPlan.db_name)
  return db_name_.GetNoArena();
}
inline void SeqScanPlan::set_db_name(const ::std::string& value) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:session.SeqScanPlan.db_name)
}
#if LANG_CXX11
inline void SeqScanPlan::set_db_name(::std::string&& value) {
  
  db_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:session.SeqScanPlan.db_name)
}
#endif
inline void SeqScanPlan::set_db_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:session.SeqScanPlan.db_name)
}
inline void SeqScanPlan::set_db_name(const char* value, size_t size) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:session.SeqScanPlan.db_name)
}
inline ::std::string* SeqScanPlan::mutable_db_name() {
  
  // @@protoc_insertion_point(field_mutable:session.SeqScanPlan.db_name)
  return db_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SeqScanPlan::release_db_name() {
  // @@protoc_insertion_point(field_release:session.SeqScanPlan.db_name)
  
  return db_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SeqScanPlan::set_allocated_db_name(::std::string* db_name) {
  if (db_name != NULL) {
    
  } else {
    
  }
  db_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_name);
  // @@protoc_insertion_point(field_set_allocated:session.SeqScanPlan.db_name)
}

// string tab_name = 2;
inline void SeqScanPlan::clear_tab_name() {
  tab_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SeqScanPlan::tab_name() const {
  // @@protoc_insertion_point(field_get:session.SeqScanPlan.tab_name)
  return tab_name_.GetNoArena();
}
inline void SeqScanPlan::set_tab_name(const ::std::string& value) {
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:session.SeqScanPlan.tab_name)
}
#if LANG_CXX11
inline void SeqScanPlan::set_tab_name(::std::string&& value) {
  
  tab_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:session.SeqScanPlan.tab_name)
}
#endif
inline void SeqScanPlan::set_tab_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:session.SeqScanPlan.tab_name)
}
inline void SeqScanPlan::set_tab_name(const char* value, size_t size) {
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:session.SeqScanPlan.tab_name)
}
inline ::std::string* SeqScanPlan::mutable_tab_name() {
  
  // @@protoc_insertion_point(field_mutable:session.SeqScanPlan.tab_name)
  return tab_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SeqScanPlan::release_tab_name() {
  // @@protoc_insertion_point(field_release:session.SeqScanPlan.tab_name)
  
  return tab_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SeqScanPlan::set_allocated_tab_name(::std::string* tab_name) {
  if (tab_name != NULL) {
    
  } else {
    
  }
  tab_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tab_name);
  // @@protoc_insertion_point(field_set_allocated:session.SeqScanPlan.tab_name)
}

// sint32 par_id = 3;
inline void SeqScanPlan::clear_par_id() {
  par_id_ = 0;
}
inline ::google::protobuf::int32 SeqScanPlan::par_id() const {
  // @@protoc_insertion_point(field_get:session.SeqScanPlan.par_id)
  return par_id_;
}
inline void SeqScanPlan::set_par_id(::google::protobuf::int32 value) {
  
  par_id_ = value;
  // @@protoc_insertion_point(field_set:session.SeqScanPlan.par_id)
}

// repeated .session.ChildPlan child = 4;
inline int SeqScanPlan::child_size() const {
  return child_.size();
}
inline void SeqScanPlan::clear_child() {
  child_.Clear();
}
inline ::session::ChildPlan* SeqScanPlan::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:session.SeqScanPlan.child)
  return child_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >*
SeqScanPlan::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:session.SeqScanPlan.child)
  return &child_;
}
inline const ::session::ChildPlan& SeqScanPlan::child(int index) const {
  // @@protoc_insertion_point(field_get:session.SeqScanPlan.child)
  return child_.Get(index);
}
inline ::session::ChildPlan* SeqScanPlan::add_child() {
  // @@protoc_insertion_point(field_add:session.SeqScanPlan.child)
  return child_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >&
SeqScanPlan::child() const {
  // @@protoc_insertion_point(field_list:session.SeqScanPlan.child)
  return child_;
}

// -------------------------------------------------------------------

// TableGetPlan

// string db_name = 1;
inline void TableGetPlan::clear_db_name() {
  db_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TableGetPlan::db_name() const {
  // @@protoc_insertion_point(field_get:session.TableGetPlan.db_name)
  return db_name_.GetNoArena();
}
inline void TableGetPlan::set_db_name(const ::std::string& value) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:session.TableGetPlan.db_name)
}
#if LANG_CXX11
inline void TableGetPlan::set_db_name(::std::string&& value) {
  
  db_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:session.TableGetPlan.db_name)
}
#endif
inline void TableGetPlan::set_db_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:session.TableGetPlan.db_name)
}
inline void TableGetPlan::set_db_name(const char* value, size_t size) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:session.TableGetPlan.db_name)
}
inline ::std::string* TableGetPlan::mutable_db_name() {
  
  // @@protoc_insertion_point(field_mutable:session.TableGetPlan.db_name)
  return db_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TableGetPlan::release_db_name() {
  // @@protoc_insertion_point(field_release:session.TableGetPlan.db_name)
  
  return db_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TableGetPlan::set_allocated_db_name(::std::string* db_name) {
  if (db_name != NULL) {
    
  } else {
    
  }
  db_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_name);
  // @@protoc_insertion_point(field_set_allocated:session.TableGetPlan.db_name)
}

// string tab_name = 2;
inline void TableGetPlan::clear_tab_name() {
  tab_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TableGetPlan::tab_name() const {
  // @@protoc_insertion_point(field_get:session.TableGetPlan.tab_name)
  return tab_name_.GetNoArena();
}
inline void TableGetPlan::set_tab_name(const ::std::string& value) {
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:session.TableGetPlan.tab_name)
}
#if LANG_CXX11
inline void TableGetPlan::set_tab_name(::std::string&& value) {
  
  tab_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:session.TableGetPlan.tab_name)
}
#endif
inline void TableGetPlan::set_tab_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:session.TableGetPlan.tab_name)
}
inline void TableGetPlan::set_tab_name(const char* value, size_t size) {
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:session.TableGetPlan.tab_name)
}
inline ::std::string* TableGetPlan::mutable_tab_name() {
  
  // @@protoc_insertion_point(field_mutable:session.TableGetPlan.tab_name)
  return tab_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TableGetPlan::release_tab_name() {
  // @@protoc_insertion_point(field_release:session.TableGetPlan.tab_name)
  
  return tab_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TableGetPlan::set_allocated_tab_name(::std::string* tab_name) {
  if (tab_name != NULL) {
    
  } else {
    
  }
  tab_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tab_name);
  // @@protoc_insertion_point(field_set_allocated:session.TableGetPlan.tab_name)
}

// sint32 par_id = 3;
inline void TableGetPlan::clear_par_id() {
  par_id_ = 0;
}
inline ::google::protobuf::int32 TableGetPlan::par_id() const {
  // @@protoc_insertion_point(field_get:session.TableGetPlan.par_id)
  return par_id_;
}
inline void TableGetPlan::set_par_id(::google::protobuf::int32 value) {
  
  par_id_ = value;
  // @@protoc_insertion_point(field_set:session.TableGetPlan.par_id)
}

// string key = 4;
inline void TableGetPlan::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TableGetPlan::key() const {
  // @@protoc_insertion_point(field_get:session.TableGetPlan.key)
  return key_.GetNoArena();
}
inline void TableGetPlan::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:session.TableGetPlan.key)
}
#if LANG_CXX11
inline void TableGetPlan::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:session.TableGetPlan.key)
}
#endif
inline void TableGetPlan::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:session.TableGetPlan.key)
}
inline void TableGetPlan::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:session.TableGetPlan.key)
}
inline ::std::string* TableGetPlan::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:session.TableGetPlan.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TableGetPlan::release_key() {
  // @@protoc_insertion_point(field_release:session.TableGetPlan.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TableGetPlan::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:session.TableGetPlan.key)
}

// repeated .session.ChildPlan child = 5;
inline int TableGetPlan::child_size() const {
  return child_.size();
}
inline void TableGetPlan::clear_child() {
  child_.Clear();
}
inline ::session::ChildPlan* TableGetPlan::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:session.TableGetPlan.child)
  return child_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >*
TableGetPlan::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:session.TableGetPlan.child)
  return &child_;
}
inline const ::session::ChildPlan& TableGetPlan::child(int index) const {
  // @@protoc_insertion_point(field_get:session.TableGetPlan.child)
  return child_.Get(index);
}
inline ::session::ChildPlan* TableGetPlan::add_child() {
  // @@protoc_insertion_point(field_add:session.TableGetPlan.child)
  return child_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >&
TableGetPlan::child() const {
  // @@protoc_insertion_point(field_list:session.TableGetPlan.child)
  return child_;
}

// -------------------------------------------------------------------

// FilterPlan

// repeated .session.Expression expression = 1;
inline int FilterPlan::expression_size() const {
  return expression_.size();
}
inline void FilterPlan::clear_expression() {
  expression_.Clear();
}
inline ::session::Expression* FilterPlan::mutable_expression(int index) {
  // @@protoc_insertion_point(field_mutable:session.FilterPlan.expression)
  return expression_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::session::Expression >*
FilterPlan::mutable_expression() {
  // @@protoc_insertion_point(field_mutable_list:session.FilterPlan.expression)
  return &expression_;
}
inline const ::session::Expression& FilterPlan::expression(int index) const {
  // @@protoc_insertion_point(field_get:session.FilterPlan.expression)
  return expression_.Get(index);
}
inline ::session::Expression* FilterPlan::add_expression() {
  // @@protoc_insertion_point(field_add:session.FilterPlan.expression)
  return expression_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::session::Expression >&
FilterPlan::expression() const {
  // @@protoc_insertion_point(field_list:session.FilterPlan.expression)
  return expression_;
}

// repeated .session.ChildPlan child = 2;
inline int FilterPlan::child_size() const {
  return child_.size();
}
inline void FilterPlan::clear_child() {
  child_.Clear();
}
inline ::session::ChildPlan* FilterPlan::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:session.FilterPlan.child)
  return child_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >*
FilterPlan::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:session.FilterPlan.child)
  return &child_;
}
inline const ::session::ChildPlan& FilterPlan::child(int index) const {
  // @@protoc_insertion_point(field_get:session.FilterPlan.child)
  return child_.Get(index);
}
inline ::session::ChildPlan* FilterPlan::add_child() {
  // @@protoc_insertion_point(field_add:session.FilterPlan.child)
  return child_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >&
FilterPlan::child() const {
  // @@protoc_insertion_point(field_list:session.FilterPlan.child)
  return child_;
}

// -------------------------------------------------------------------

// InsertPlan

// string db_name = 1;
inline void InsertPlan::clear_db_name() {
  db_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InsertPlan::db_name() const {
  // @@protoc_insertion_point(field_get:session.InsertPlan.db_name)
  return db_name_.GetNoArena();
}
inline void InsertPlan::set_db_name(const ::std::string& value) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:session.InsertPlan.db_name)
}
#if LANG_CXX11
inline void InsertPlan::set_db_name(::std::string&& value) {
  
  db_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:session.InsertPlan.db_name)
}
#endif
inline void InsertPlan::set_db_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:session.InsertPlan.db_name)
}
inline void InsertPlan::set_db_name(const char* value, size_t size) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:session.InsertPlan.db_name)
}
inline ::std::string* InsertPlan::mutable_db_name() {
  
  // @@protoc_insertion_point(field_mutable:session.InsertPlan.db_name)
  return db_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InsertPlan::release_db_name() {
  // @@protoc_insertion_point(field_release:session.InsertPlan.db_name)
  
  return db_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InsertPlan::set_allocated_db_name(::std::string* db_name) {
  if (db_name != NULL) {
    
  } else {
    
  }
  db_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_name);
  // @@protoc_insertion_point(field_set_allocated:session.InsertPlan.db_name)
}

// string tab_name = 2;
inline void InsertPlan::clear_tab_name() {
  tab_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InsertPlan::tab_name() const {
  // @@protoc_insertion_point(field_get:session.InsertPlan.tab_name)
  return tab_name_.GetNoArena();
}
inline void InsertPlan::set_tab_name(const ::std::string& value) {
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:session.InsertPlan.tab_name)
}
#if LANG_CXX11
inline void InsertPlan::set_tab_name(::std::string&& value) {
  
  tab_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:session.InsertPlan.tab_name)
}
#endif
inline void InsertPlan::set_tab_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:session.InsertPlan.tab_name)
}
inline void InsertPlan::set_tab_name(const char* value, size_t size) {
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:session.InsertPlan.tab_name)
}
inline ::std::string* InsertPlan::mutable_tab_name() {
  
  // @@protoc_insertion_point(field_mutable:session.InsertPlan.tab_name)
  return tab_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InsertPlan::release_tab_name() {
  // @@protoc_insertion_point(field_release:session.InsertPlan.tab_name)
  
  return tab_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InsertPlan::set_allocated_tab_name(::std::string* tab_name) {
  if (tab_name != NULL) {
    
  } else {
    
  }
  tab_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tab_name);
  // @@protoc_insertion_point(field_set_allocated:session.InsertPlan.tab_name)
}

// sint32 par_id = 3;
inline void InsertPlan::clear_par_id() {
  par_id_ = 0;
}
inline ::google::protobuf::int32 InsertPlan::par_id() const {
  // @@protoc_insertion_point(field_get:session.InsertPlan.par_id)
  return par_id_;
}
inline void InsertPlan::set_par_id(::google::protobuf::int32 value) {
  
  par_id_ = value;
  // @@protoc_insertion_point(field_set:session.InsertPlan.par_id)
}

// repeated .session.ChildPlan child = 4;
inline int InsertPlan::child_size() const {
  return child_.size();
}
inline void InsertPlan::clear_child() {
  child_.Clear();
}
inline ::session::ChildPlan* InsertPlan::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:session.InsertPlan.child)
  return child_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >*
InsertPlan::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:session.InsertPlan.child)
  return &child_;
}
inline const ::session::ChildPlan& InsertPlan::child(int index) const {
  // @@protoc_insertion_point(field_get:session.InsertPlan.child)
  return child_.Get(index);
}
inline ::session::ChildPlan* InsertPlan::add_child() {
  // @@protoc_insertion_point(field_add:session.InsertPlan.child)
  return child_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >&
InsertPlan::child() const {
  // @@protoc_insertion_point(field_list:session.InsertPlan.child)
  return child_;
}

// -------------------------------------------------------------------

// DeletePlan

// string db_name = 1;
inline void DeletePlan::clear_db_name() {
  db_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeletePlan::db_name() const {
  // @@protoc_insertion_point(field_get:session.DeletePlan.db_name)
  return db_name_.GetNoArena();
}
inline void DeletePlan::set_db_name(const ::std::string& value) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:session.DeletePlan.db_name)
}
#if LANG_CXX11
inline void DeletePlan::set_db_name(::std::string&& value) {
  
  db_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:session.DeletePlan.db_name)
}
#endif
inline void DeletePlan::set_db_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:session.DeletePlan.db_name)
}
inline void DeletePlan::set_db_name(const char* value, size_t size) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:session.DeletePlan.db_name)
}
inline ::std::string* DeletePlan::mutable_db_name() {
  
  // @@protoc_insertion_point(field_mutable:session.DeletePlan.db_name)
  return db_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeletePlan::release_db_name() {
  // @@protoc_insertion_point(field_release:session.DeletePlan.db_name)
  
  return db_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeletePlan::set_allocated_db_name(::std::string* db_name) {
  if (db_name != NULL) {
    
  } else {
    
  }
  db_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_name);
  // @@protoc_insertion_point(field_set_allocated:session.DeletePlan.db_name)
}

// string tab_name = 2;
inline void DeletePlan::clear_tab_name() {
  tab_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeletePlan::tab_name() const {
  // @@protoc_insertion_point(field_get:session.DeletePlan.tab_name)
  return tab_name_.GetNoArena();
}
inline void DeletePlan::set_tab_name(const ::std::string& value) {
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:session.DeletePlan.tab_name)
}
#if LANG_CXX11
inline void DeletePlan::set_tab_name(::std::string&& value) {
  
  tab_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:session.DeletePlan.tab_name)
}
#endif
inline void DeletePlan::set_tab_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:session.DeletePlan.tab_name)
}
inline void DeletePlan::set_tab_name(const char* value, size_t size) {
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:session.DeletePlan.tab_name)
}
inline ::std::string* DeletePlan::mutable_tab_name() {
  
  // @@protoc_insertion_point(field_mutable:session.DeletePlan.tab_name)
  return tab_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeletePlan::release_tab_name() {
  // @@protoc_insertion_point(field_release:session.DeletePlan.tab_name)
  
  return tab_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeletePlan::set_allocated_tab_name(::std::string* tab_name) {
  if (tab_name != NULL) {
    
  } else {
    
  }
  tab_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tab_name);
  // @@protoc_insertion_point(field_set_allocated:session.DeletePlan.tab_name)
}

// sint32 par_id = 3;
inline void DeletePlan::clear_par_id() {
  par_id_ = 0;
}
inline ::google::protobuf::int32 DeletePlan::par_id() const {
  // @@protoc_insertion_point(field_get:session.DeletePlan.par_id)
  return par_id_;
}
inline void DeletePlan::set_par_id(::google::protobuf::int32 value) {
  
  par_id_ = value;
  // @@protoc_insertion_point(field_set:session.DeletePlan.par_id)
}

// repeated .session.ChildPlan child = 4;
inline int DeletePlan::child_size() const {
  return child_.size();
}
inline void DeletePlan::clear_child() {
  child_.Clear();
}
inline ::session::ChildPlan* DeletePlan::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:session.DeletePlan.child)
  return child_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >*
DeletePlan::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:session.DeletePlan.child)
  return &child_;
}
inline const ::session::ChildPlan& DeletePlan::child(int index) const {
  // @@protoc_insertion_point(field_get:session.DeletePlan.child)
  return child_.Get(index);
}
inline ::session::ChildPlan* DeletePlan::add_child() {
  // @@protoc_insertion_point(field_add:session.DeletePlan.child)
  return child_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >&
DeletePlan::child() const {
  // @@protoc_insertion_point(field_list:session.DeletePlan.child)
  return child_;
}

// -------------------------------------------------------------------

// UpdatePlan

// string db_name = 1;
inline void UpdatePlan::clear_db_name() {
  db_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UpdatePlan::db_name() const {
  // @@protoc_insertion_point(field_get:session.UpdatePlan.db_name)
  return db_name_.GetNoArena();
}
inline void UpdatePlan::set_db_name(const ::std::string& value) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:session.UpdatePlan.db_name)
}
#if LANG_CXX11
inline void UpdatePlan::set_db_name(::std::string&& value) {
  
  db_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:session.UpdatePlan.db_name)
}
#endif
inline void UpdatePlan::set_db_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:session.UpdatePlan.db_name)
}
inline void UpdatePlan::set_db_name(const char* value, size_t size) {
  
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:session.UpdatePlan.db_name)
}
inline ::std::string* UpdatePlan::mutable_db_name() {
  
  // @@protoc_insertion_point(field_mutable:session.UpdatePlan.db_name)
  return db_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdatePlan::release_db_name() {
  // @@protoc_insertion_point(field_release:session.UpdatePlan.db_name)
  
  return db_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdatePlan::set_allocated_db_name(::std::string* db_name) {
  if (db_name != NULL) {
    
  } else {
    
  }
  db_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_name);
  // @@protoc_insertion_point(field_set_allocated:session.UpdatePlan.db_name)
}

// string tab_name = 2;
inline void UpdatePlan::clear_tab_name() {
  tab_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UpdatePlan::tab_name() const {
  // @@protoc_insertion_point(field_get:session.UpdatePlan.tab_name)
  return tab_name_.GetNoArena();
}
inline void UpdatePlan::set_tab_name(const ::std::string& value) {
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:session.UpdatePlan.tab_name)
}
#if LANG_CXX11
inline void UpdatePlan::set_tab_name(::std::string&& value) {
  
  tab_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:session.UpdatePlan.tab_name)
}
#endif
inline void UpdatePlan::set_tab_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:session.UpdatePlan.tab_name)
}
inline void UpdatePlan::set_tab_name(const char* value, size_t size) {
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:session.UpdatePlan.tab_name)
}
inline ::std::string* UpdatePlan::mutable_tab_name() {
  
  // @@protoc_insertion_point(field_mutable:session.UpdatePlan.tab_name)
  return tab_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdatePlan::release_tab_name() {
  // @@protoc_insertion_point(field_release:session.UpdatePlan.tab_name)
  
  return tab_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdatePlan::set_allocated_tab_name(::std::string* tab_name) {
  if (tab_name != NULL) {
    
  } else {
    
  }
  tab_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tab_name);
  // @@protoc_insertion_point(field_set_allocated:session.UpdatePlan.tab_name)
}

// sint32 par_id = 3;
inline void UpdatePlan::clear_par_id() {
  par_id_ = 0;
}
inline ::google::protobuf::int32 UpdatePlan::par_id() const {
  // @@protoc_insertion_point(field_get:session.UpdatePlan.par_id)
  return par_id_;
}
inline void UpdatePlan::set_par_id(::google::protobuf::int32 value) {
  
  par_id_ = value;
  // @@protoc_insertion_point(field_set:session.UpdatePlan.par_id)
}

// repeated .session.ChildPlan child = 4;
inline int UpdatePlan::child_size() const {
  return child_.size();
}
inline void UpdatePlan::clear_child() {
  child_.Clear();
}
inline ::session::ChildPlan* UpdatePlan::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:session.UpdatePlan.child)
  return child_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >*
UpdatePlan::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:session.UpdatePlan.child)
  return &child_;
}
inline const ::session::ChildPlan& UpdatePlan::child(int index) const {
  // @@protoc_insertion_point(field_get:session.UpdatePlan.child)
  return child_.Get(index);
}
inline ::session::ChildPlan* UpdatePlan::add_child() {
  // @@protoc_insertion_point(field_add:session.UpdatePlan.child)
  return child_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >&
UpdatePlan::child() const {
  // @@protoc_insertion_point(field_list:session.UpdatePlan.child)
  return child_;
}

// -------------------------------------------------------------------

// ProjectionPlan

// string tab_name = 1;
inline void ProjectionPlan::clear_tab_name() {
  tab_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProjectionPlan::tab_name() const {
  // @@protoc_insertion_point(field_get:session.ProjectionPlan.tab_name)
  return tab_name_.GetNoArena();
}
inline void ProjectionPlan::set_tab_name(const ::std::string& value) {
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:session.ProjectionPlan.tab_name)
}
#if LANG_CXX11
inline void ProjectionPlan::set_tab_name(::std::string&& value) {
  
  tab_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:session.ProjectionPlan.tab_name)
}
#endif
inline void ProjectionPlan::set_tab_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:session.ProjectionPlan.tab_name)
}
inline void ProjectionPlan::set_tab_name(const char* value, size_t size) {
  
  tab_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:session.ProjectionPlan.tab_name)
}
inline ::std::string* ProjectionPlan::mutable_tab_name() {
  
  // @@protoc_insertion_point(field_mutable:session.ProjectionPlan.tab_name)
  return tab_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProjectionPlan::release_tab_name() {
  // @@protoc_insertion_point(field_release:session.ProjectionPlan.tab_name)
  
  return tab_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProjectionPlan::set_allocated_tab_name(::std::string* tab_name) {
  if (tab_name != NULL) {
    
  } else {
    
  }
  tab_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tab_name);
  // @@protoc_insertion_point(field_set_allocated:session.ProjectionPlan.tab_name)
}

// repeated string col_name = 2;
inline int ProjectionPlan::col_name_size() const {
  return col_name_.size();
}
inline void ProjectionPlan::clear_col_name() {
  col_name_.Clear();
}
inline const ::std::string& ProjectionPlan::col_name(int index) const {
  // @@protoc_insertion_point(field_get:session.ProjectionPlan.col_name)
  return col_name_.Get(index);
}
inline ::std::string* ProjectionPlan::mutable_col_name(int index) {
  // @@protoc_insertion_point(field_mutable:session.ProjectionPlan.col_name)
  return col_name_.Mutable(index);
}
inline void ProjectionPlan::set_col_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:session.ProjectionPlan.col_name)
  col_name_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ProjectionPlan::set_col_name(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:session.ProjectionPlan.col_name)
  col_name_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ProjectionPlan::set_col_name(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  col_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:session.ProjectionPlan.col_name)
}
inline void ProjectionPlan::set_col_name(int index, const char* value, size_t size) {
  col_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:session.ProjectionPlan.col_name)
}
inline ::std::string* ProjectionPlan::add_col_name() {
  // @@protoc_insertion_point(field_add_mutable:session.ProjectionPlan.col_name)
  return col_name_.Add();
}
inline void ProjectionPlan::add_col_name(const ::std::string& value) {
  col_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:session.ProjectionPlan.col_name)
}
#if LANG_CXX11
inline void ProjectionPlan::add_col_name(::std::string&& value) {
  col_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:session.ProjectionPlan.col_name)
}
#endif
inline void ProjectionPlan::add_col_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  col_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:session.ProjectionPlan.col_name)
}
inline void ProjectionPlan::add_col_name(const char* value, size_t size) {
  col_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:session.ProjectionPlan.col_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ProjectionPlan::col_name() const {
  // @@protoc_insertion_point(field_list:session.ProjectionPlan.col_name)
  return col_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ProjectionPlan::mutable_col_name() {
  // @@protoc_insertion_point(field_mutable_list:session.ProjectionPlan.col_name)
  return &col_name_;
}

// repeated .session.ChildPlan child = 3;
inline int ProjectionPlan::child_size() const {
  return child_.size();
}
inline void ProjectionPlan::clear_child() {
  child_.Clear();
}
inline ::session::ChildPlan* ProjectionPlan::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:session.ProjectionPlan.child)
  return child_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >*
ProjectionPlan::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:session.ProjectionPlan.child)
  return &child_;
}
inline const ::session::ChildPlan& ProjectionPlan::child(int index) const {
  // @@protoc_insertion_point(field_get:session.ProjectionPlan.child)
  return child_.Get(index);
}
inline ::session::ChildPlan* ProjectionPlan::add_child() {
  // @@protoc_insertion_point(field_add:session.ProjectionPlan.child)
  return child_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >&
ProjectionPlan::child() const {
  // @@protoc_insertion_point(field_list:session.ProjectionPlan.child)
  return child_;
}

// -------------------------------------------------------------------

// NestedLoopJoin

// .session.JoinType jointype = 1;
inline void NestedLoopJoin::clear_jointype() {
  jointype_ = 0;
}
inline ::session::JoinType NestedLoopJoin::jointype() const {
  // @@protoc_insertion_point(field_get:session.NestedLoopJoin.jointype)
  return static_cast< ::session::JoinType >(jointype_);
}
inline void NestedLoopJoin::set_jointype(::session::JoinType value) {
  
  jointype_ = value;
  // @@protoc_insertion_point(field_set:session.NestedLoopJoin.jointype)
}

// repeated .session.ChildPlan child = 2;
inline int NestedLoopJoin::child_size() const {
  return child_.size();
}
inline void NestedLoopJoin::clear_child() {
  child_.Clear();
}
inline ::session::ChildPlan* NestedLoopJoin::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:session.NestedLoopJoin.child)
  return child_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >*
NestedLoopJoin::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:session.NestedLoopJoin.child)
  return &child_;
}
inline const ::session::ChildPlan& NestedLoopJoin::child(int index) const {
  // @@protoc_insertion_point(field_get:session.NestedLoopJoin.child)
  return child_.Get(index);
}
inline ::session::ChildPlan* NestedLoopJoin::add_child() {
  // @@protoc_insertion_point(field_add:session.NestedLoopJoin.child)
  return child_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >&
NestedLoopJoin::child() const {
  // @@protoc_insertion_point(field_list:session.NestedLoopJoin.child)
  return child_;
}

// -------------------------------------------------------------------

// DistributedPlan_Node

// string ip_addr = 1;
inline void DistributedPlan_Node::clear_ip_addr() {
  ip_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DistributedPlan_Node::ip_addr() const {
  // @@protoc_insertion_point(field_get:session.DistributedPlan.Node.ip_addr)
  return ip_addr_.GetNoArena();
}
inline void DistributedPlan_Node::set_ip_addr(const ::std::string& value) {
  
  ip_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:session.DistributedPlan.Node.ip_addr)
}
#if LANG_CXX11
inline void DistributedPlan_Node::set_ip_addr(::std::string&& value) {
  
  ip_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:session.DistributedPlan.Node.ip_addr)
}
#endif
inline void DistributedPlan_Node::set_ip_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:session.DistributedPlan.Node.ip_addr)
}
inline void DistributedPlan_Node::set_ip_addr(const char* value, size_t size) {
  
  ip_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:session.DistributedPlan.Node.ip_addr)
}
inline ::std::string* DistributedPlan_Node::mutable_ip_addr() {
  
  // @@protoc_insertion_point(field_mutable:session.DistributedPlan.Node.ip_addr)
  return ip_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DistributedPlan_Node::release_ip_addr() {
  // @@protoc_insertion_point(field_release:session.DistributedPlan.Node.ip_addr)
  
  return ip_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DistributedPlan_Node::set_allocated_ip_addr(::std::string* ip_addr) {
  if (ip_addr != NULL) {
    
  } else {
    
  }
  ip_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_addr);
  // @@protoc_insertion_point(field_set_allocated:session.DistributedPlan.Node.ip_addr)
}

// sint32 port = 2;
inline void DistributedPlan_Node::clear_port() {
  port_ = 0;
}
inline ::google::protobuf::int32 DistributedPlan_Node::port() const {
  // @@protoc_insertion_point(field_get:session.DistributedPlan.Node.port)
  return port_;
}
inline void DistributedPlan_Node::set_port(::google::protobuf::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:session.DistributedPlan.Node.port)
}

// -------------------------------------------------------------------

// DistributedPlan

// repeated .session.DistributedPlan.Node nodes = 1;
inline int DistributedPlan::nodes_size() const {
  return nodes_.size();
}
inline void DistributedPlan::clear_nodes() {
  nodes_.Clear();
}
inline ::session::DistributedPlan_Node* DistributedPlan::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:session.DistributedPlan.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::session::DistributedPlan_Node >*
DistributedPlan::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:session.DistributedPlan.nodes)
  return &nodes_;
}
inline const ::session::DistributedPlan_Node& DistributedPlan::nodes(int index) const {
  // @@protoc_insertion_point(field_get:session.DistributedPlan.nodes)
  return nodes_.Get(index);
}
inline ::session::DistributedPlan_Node* DistributedPlan::add_nodes() {
  // @@protoc_insertion_point(field_add:session.DistributedPlan.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::session::DistributedPlan_Node >&
DistributedPlan::nodes() const {
  // @@protoc_insertion_point(field_list:session.DistributedPlan.nodes)
  return nodes_;
}

// repeated .session.ChildPlan plans = 2;
inline int DistributedPlan::plans_size() const {
  return plans_.size();
}
inline void DistributedPlan::clear_plans() {
  plans_.Clear();
}
inline ::session::ChildPlan* DistributedPlan::mutable_plans(int index) {
  // @@protoc_insertion_point(field_mutable:session.DistributedPlan.plans)
  return plans_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >*
DistributedPlan::mutable_plans() {
  // @@protoc_insertion_point(field_mutable_list:session.DistributedPlan.plans)
  return &plans_;
}
inline const ::session::ChildPlan& DistributedPlan::plans(int index) const {
  // @@protoc_insertion_point(field_get:session.DistributedPlan.plans)
  return plans_.Get(index);
}
inline ::session::ChildPlan* DistributedPlan::add_plans() {
  // @@protoc_insertion_point(field_add:session.DistributedPlan.plans)
  return plans_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::session::ChildPlan >&
DistributedPlan::plans() const {
  // @@protoc_insertion_point(field_list:session.DistributedPlan.plans)
  return plans_;
}

// -------------------------------------------------------------------

// RemotePlan

// .session.ChildPlan child = 1;
inline bool RemotePlan::has_child() const {
  return this != internal_default_instance() && child_ != NULL;
}
inline void RemotePlan::clear_child() {
  if (GetArenaNoVirtual() == NULL && child_ != NULL) {
    delete child_;
  }
  child_ = NULL;
}
inline const ::session::ChildPlan& RemotePlan::_internal_child() const {
  return *child_;
}
inline const ::session::ChildPlan& RemotePlan::child() const {
  const ::session::ChildPlan* p = child_;
  // @@protoc_insertion_point(field_get:session.RemotePlan.child)
  return p != NULL ? *p : *reinterpret_cast<const ::session::ChildPlan*>(
      &::session::_ChildPlan_default_instance_);
}
inline ::session::ChildPlan* RemotePlan::release_child() {
  // @@protoc_insertion_point(field_release:session.RemotePlan.child)
  
  ::session::ChildPlan* temp = child_;
  child_ = NULL;
  return temp;
}
inline ::session::ChildPlan* RemotePlan::mutable_child() {
  
  if (child_ == NULL) {
    auto* p = CreateMaybeMessage<::session::ChildPlan>(GetArenaNoVirtual());
    child_ = p;
  }
  // @@protoc_insertion_point(field_mutable:session.RemotePlan.child)
  return child_;
}
inline void RemotePlan::set_allocated_child(::session::ChildPlan* child) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete child_;
  }
  if (child) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      child = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:session.RemotePlan.child)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace session

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::session::JoinType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::session::JoinType>() {
  return ::session::JoinType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_session_2eproto
